<!DOCTYPE html>
<html class="nojs html" lang="zh-CN">
 <head>

  <meta http-equiv="Content-type" content="text/html;charset=UTF-8"/>
  <meta name="generator" content="2018.1.0.386"/>
  
  <script type="text/javascript">
   // Update the 'nojs'/'js' class on the html node
document.documentElement.className = document.documentElement.className.replace(/\bnojs\b/g, 'js');

// Check that all required assets are uploaded and up-to-date
if(typeof Muse == "undefined") window.Muse = {}; window.Muse.assets = {"required":["museutils.js", "museconfig.js", "jquery.musepolyfill.bgsize.js", "jquery.watch.js", "require.js", "index.css"], "outOfDate":[]};
</script>
  
  <title>熊孩子</title>
  <!-- CSS -->
  <link rel="stylesheet" type="text/css" href="css/site_global.css?crc=444006867"/>
  <link rel="stylesheet" type="text/css" href="css/index.css?crc=512648160" id="pagesheet"/>
    <!--HTML Widget code-->
  
<style>
body {
  overflow-x: hidden;
}
</style>

<style>
.gs {
  background-color: #0E1E28;
  color: #fff;
  text-align: center;
}
</style>

<style>
.scene {
  padding: 0;
  margin: 0;
}

.layer{
-webkit-transform-origin: center;
-ms-transform-origin: center;
-o-transform-origin: center;
transform-origin: center;
}
</style>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/swiper@4.1.6/dist/css/swiper.min.css">
<script src="https://cdn.jsdelivr.net/npm/swiper@4.1.6/dist/js/swiper.min.js"></script>

<style>
.swiper-container1 {
    position: absolute;
    top: 0px;
    width: 100%;
    height: 100%;
    padding-top: 0px;
    padding-bottom: 0px;
    overflow: hidden;
}
.swiper-slide {
  -webkit-transform-origin: center;
  -ms-transform-origin: center;
  -o-transform-origin: center;
  transform-origin: center;
    background-position: center;
    background-size: cover;
    text-align: center;
    font-size: 18px;
    background: transparent;
}
.swiper-slide a {
  pointer-events: none;
}
.swiper-wrapper img {
  width: 100%;
  height: 100%;
  object-fit: contain;
  object-position: center center;
  font-family: 'object-fit: contain; object-position: center center;'
}
.swiper-container1 .swiper-pagination-bullet {
  border-radius: 100px;
  background: #FFFFFF;
  width: 20px;
  height: 20px;
  opacity: 1;
}
.swiper-container1 .swiper-pagination-bullet-active {
  background: #FFFFFF;
  opacity: 1;
}
.swiper-container1 .swiper-pagination-fraction {
  font-size: 16px;
  color: #FFFFFF;
  bottom: 10px;
}
.swiper-container1 .swiper-pagination-progressbar {
  background: rgba(0,0,0,0.25);
}
.swiper-container1 .swiper-pagination-progressbar .swiper-pagination-progressbar-fill {
  background: #330067;
}
.swiper-container1 > div.swiper-pagination.swiper-pagination-progressbar {
  height: 4px;
}
.prev {
  cursor: pointer;
  cursor: url(Add File), auto;
}
.next {
  cursor: pointer;
  cursor: url(Add File), auto;
}
.swiper-container1 .swiper-scrollbar {
  background: rgba(255,255,255,0.1);
}
.swiper-container1 .swiper-scrollbar-drag {
  background: rgba(255,255,255,0.5);
}
.pstr1 {
  text-align: center;
}
</style>

 </head>
 <body>

  <div class="clearfix" id="page"><!-- column -->
   <div class="position_content" id="page_position_content">
    <div class="colelem" id="u94"><!-- custom html -->
     <html>
<body>
<center>
<video src="http://kexkeli.cn/xhz/xhzban.mp4" loop autoplay muted width="1800" height="1013">
</video>

</center>
</body>
</html>

    </div>
    <div class="colelem" id="u1279"><!-- custom html -->
     <center><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=680 height=52 src="//music.163.com/outchain/player?type=2&id=464015775&auto=1&height=32"></iframe></center>
    </div>
    <div class="size_fixed colelem" id="u1314"><!-- custom html -->
     

    </div>
    <div class="size_fixed colelem" id="u106"><!-- custom html -->
     

    </div>
    <div class="clearfix colelem" id="u116-28"><!-- content -->
     <p>这是个很‘折磨人’的项目</p>
     <p>&nbsp;</p>
     <p>我依旧记得项目经理的叮嘱，客户可是有设计师的，但人家很忙不像你，“需要付出十分的努力，被投诉就不好了”</p>
     <p>&nbsp;</p>
     <p>​好在领导了解情况后给我充分的时间</p>
     <p>&nbsp;</p>
     <p>​另一方面，这也是紧急的项目，甲方急着上线，或多或少放水吧两个星期就完工了。整理确认稿的时候我发誓我要</p>
     <p>&nbsp;</p>
     <p>一个星期不用illustrator（真香～）</p>
     <p>&nbsp;</p>
     <p>本人是手(鼠)残(绘) 业余设计爱好者，过程中也借鉴了很多参考，也在过程中学到很多东西</p>
     <p>&nbsp;</p>
     <p>事后，项目经理说：知道为什么让你来做吗？因为你也是熊孩子……</p>
     <p>&nbsp;</p>
     <p>SO SO</p>
     <p>&nbsp;</p>
     <p>at last （除甲方提供的角色图外皆为项目成品）</p>
    </div>
    <div class="browser_width colelem" id="u667-bw">
     <div class="museBGSize scene2" id="u667"><!-- group -->
      <div class="clearfix" id="u667_align_to_page">
       <div class="size_fixed grpelem" id="u522"><!-- custom html -->
        

       </div>
       <div class="clearfix grpelem" id="u634"><!-- group -->
        <div class="layer19 clip_frame grpelem" id="u620"><!-- image -->
         <img class="block" id="u620_img" src="images/%e6%9c%aa%e6%a0%87%e9%a2%98-4-%e7%9f%a2%e9%87%8f%e6%99%ba%e8%83%bd%e5%af%b9%e8%b1%a1%20%e6%8b%b7%e8%b4%9d%202c.png?crc=3800856712" alt="" width="1200" height="101"/>
        </div>
        <div class="clip_frame grpelem" id="u613"><!-- image -->
         <img class="block" id="u613_img" src="images/%e6%9c%aa%e6%a0%87%e9%a2%98-4-%e7%9f%a2%e9%87%8f%e6%99%ba%e8%83%bd%e5%af%b9%e8%b1%a1c.png?crc=382255233" alt="" width="247" height="149"/>
        </div>
        <div class="layer17 clip_frame grpelem" id="u606"><!-- image -->
         <img class="block" id="u606_img" src="images/%e6%9c%aa%e6%a0%87%e9%a2%98-4-%e5%9b%be%e5%b1%82%2012c.png?crc=3793956639" alt="" width="54" height="73"/>
        </div>
        <div class="layer16 clip_frame grpelem" id="u599"><!-- image -->
         <img class="block" id="u599_img" src="images/%e6%9c%aa%e6%a0%87%e9%a2%98-4-%e5%bd%a2%e7%8a%b6%201c.png?crc=3982508089" alt="" width="350" height="144"/>
        </div>
        <div class="layer15 clip_frame grpelem" id="u592"><!-- image -->
         <img class="block" id="u592_img" src="images/%e6%9c%aa%e6%a0%87%e9%a2%98-4-%e7%9f%a2%e9%87%8f%e6%99%ba%e8%83%bd%e5%af%b9%e8%b1%a1%20%e6%8b%b7%e8%b4%9dc.png?crc=4079515846" alt="" width="264" height="235"/>
        </div>
        <div class="clip_frame grpelem" id="u585"><!-- image -->
         <img class="block" id="u585_img" src="images/%e6%9c%aa%e6%a0%87%e9%a2%98-4-%e7%9f%a2%e9%87%8f%e6%99%ba%e8%83%bd%e5%af%b9%e8%b1%a1c2.png?crc=4019798282" alt="" width="235" height="123"/>
        </div>
        <div class="layer13 clip_frame grpelem" id="u578"><!-- image -->
         <img class="block" id="u578_img" src="images/%e6%9c%aa%e6%a0%87%e9%a2%98-4-%e7%9f%a2%e9%87%8f%e6%99%ba%e8%83%bd%e5%af%b9%e8%b1%a1%20%e6%8b%b7%e8%b4%9d%203%ef%bc%88%e5%90%88%e5%b9%b6%ef%bc%89c.png?crc=4183418512" alt="" width="95" height="75"/>
        </div>
        <div class="layer12 clip_frame grpelem" id="u571"><!-- image -->
         <img class="block" id="u571_img" src="images/%e6%9c%aa%e6%a0%87%e9%a2%98-4-%e7%9f%a2%e9%87%8f%e6%99%ba%e8%83%bd%e5%af%b9%e8%b1%a15%20%e6%8b%b7%e8%b4%9dc.png?crc=3833371232" alt="" width="148" height="163"/>
        </div>
        <div class="layer11 clip_frame grpelem" id="u564"><!-- image -->
         <img class="block" id="u564_img" src="images/%e6%9c%aa%e6%a0%87%e9%a2%98-4-%e7%9f%a2%e9%87%8f%e6%99%ba%e8%83%bd%e5%af%b9%e8%b1%a15%20%e6%8b%b7%e8%b4%9d%202c.png?crc=173060749" alt="" width="148" height="163"/>
        </div>
       </div>
      </div>
     </div>
    </div>
    <div class="browser_width colelem" id="u543-bw">
     <div class="museBGSize scene1" id="u543"><!-- group -->
      <div class="clearfix" id="u543_align_to_page">
       <div class="size_fixed grpelem" id="u687"><!-- custom html -->
        

       </div>
       <div class="clearfix grpelem" id="u557"><!-- group -->
        <div class="layer2 clip_frame grpelem" id="u237"><!-- image -->
         <img class="block" id="u237_img" src="images/%e6%9c%aa%e6%a0%87%e9%a2%98-1-%e7%9f%a2%e9%87%8f%e6%99%ba%e8%83%bd%e5%af%b9%e8%b1%a1c.png?crc=20434790" alt="" width="48" height="48"/>
        </div>
        <div class="clip_frame grpelem" id="u265"><!-- image -->
         <img class="block" id="u265_img" src="images/%e6%9c%aa%e6%a0%87%e9%a2%98-1-%e7%9f%a2%e9%87%8f%e6%99%ba%e8%83%bd%e5%af%b9%e8%b1%a1c2.png?crc=3801964520" alt="" width="407" height="138"/>
        </div>
        <div class="layer5 clip_frame grpelem" id="u258"><!-- image -->
         <img class="block" id="u258_img" src="images/%e6%9c%aa%e6%a0%87%e9%a2%98-1-%e7%9f%a2%e9%87%8f%e6%99%ba%e8%83%bd%e5%af%b9%e8%b1%a1c3.png?crc=3758497142" alt="" width="1008" height="235"/>
        </div>
        <div class="layer4 clip_frame grpelem" id="u251"><!-- image -->
         <img class="block" id="u251_img" src="images/%e6%9c%aa%e6%a0%87%e9%a2%98-1-%e7%9f%a2%e9%87%8f%e6%99%ba%e8%83%bd%e5%af%b9%e8%b1%a1c4.png?crc=3761355699" alt="" width="38" height="23"/>
        </div>
        <div class="layer3 clip_frame grpelem" id="u244"><!-- image -->
         <img class="block" id="u244_img" src="images/%e6%9c%aa%e6%a0%87%e9%a2%98-1-%e7%9f%a2%e9%87%8f%e6%99%ba%e8%83%bd%e5%af%b9%e8%b1%a1c5.png?crc=3944802162" alt="" width="120" height="57"/>
        </div>
        <div class="layer1 clip_frame grpelem" id="u230"><!-- image -->
         <img class="block" id="u230_img" src="images/%e6%9c%aa%e6%a0%87%e9%a2%98-1-tb2rgjld7fb_ujksnavxxxfmvxa___1872810511c.png?crc=3795090819" alt="" width="268" height="237"/>
        </div>
       </div>
      </div>
     </div>
    </div>
    <div class="browser_width colelem" id="u770-bw">
     <div class="scene3 museBGSize" id="u770"><!-- group -->
      <div class="clearfix" id="u770_align_to_page">
       <div class="size_fixed grpelem" id="u787"><!-- custom html -->
        

       </div>
       <div class="clearfix grpelem" id="u746"><!-- group -->
        <div class="layer19 clip_frame grpelem" id="u732"><!-- image -->
         <img class="block" id="u732_img" src="images/%e6%9c%aa%e6%a0%87%e9%a2%98-5-%e7%9f%a2%e9%87%8f%e6%99%ba%e8%83%bd%e5%af%b9%e8%b1%a1c.png?crc=3833589409" alt="" width="1200" height="147"/>
        </div>
        <div class="layer34 clip_frame grpelem" id="u725"><!-- image -->
         <img class="block" id="u725_img" src="images/%e6%9c%aa%e6%a0%87%e9%a2%98-5-%e7%9f%a2%e9%87%8f%e6%99%ba%e8%83%bd%e5%af%b9%e8%b1%a1c2.png?crc=147972405" alt="" width="60" height="93"/>
        </div>
        <div class="layer33 clip_frame grpelem" id="u718"><!-- image -->
         <img class="block" id="u718_img" src="images/%e6%9c%aa%e6%a0%87%e9%a2%98-5-%e7%9f%a2%e9%87%8f%e6%99%ba%e8%83%bd%e5%af%b9%e8%b1%a1c3.png?crc=4138166138" alt="" width="151" height="76"/>
        </div>
        <div class="layer32 clip_frame grpelem" id="u711"><!-- image -->
         <img class="block" id="u711_img" src="images/%e6%9c%aa%e6%a0%87%e9%a2%98-5-%e7%9f%a2%e9%87%8f%e6%99%ba%e8%83%bd%e5%af%b9%e8%b1%a1c4.png?crc=3786815454" alt="" width="103" height="49"/>
        </div>
        <div class="layer31 clip_frame grpelem" id="u704"><!-- image -->
         <img class="block" id="u704_img" src="images/%e6%9c%aa%e6%a0%87%e9%a2%98-5-%e7%9f%a2%e9%87%8f%e6%99%ba%e8%83%bd%e5%af%b9%e8%b1%a14c.png?crc=296408043" alt="" width="239" height="191"/>
        </div>
       </div>
      </div>
     </div>
    </div>
    <div class="browser_width colelem" id="u950-bw">
     <div class="scene4 museBGSize" id="u950"><!-- group -->
      <div class="clearfix" id="u950_align_to_page">
       <div class="clearfix grpelem" id="u902"><!-- group -->
        <div class="clearfix grpelem" id="pu888"><!-- group -->
         <div class="layer412 clip_frame grpelem" id="u888"><!-- image -->
          <img class="block" id="u888_img" src="images/%e6%9c%aa%e6%a0%87%e9%a2%98-3-tb2cuuierln8kjjszfpxxbzavxa___1872810511c.png?crc=158022873" alt="" width="56" height="63"/>
         </div>
         <div class="clip_frame grpelem" id="u881"><!-- image -->
          <img class="block" id="u881_img" src="images/%e6%9c%aa%e6%a0%87%e9%a2%98-3-tb2.3hgd7fb_ujkhfnrxxc3vpxa___1872810511c.png?crc=320115157" alt="" width="433" height="201"/>
         </div>
         <div class="layer411 clip_frame grpelem" id="u874"><!-- image -->
          <img class="block" id="u874_img" src="images/%e6%9c%aa%e6%a0%87%e9%a2%98-3-tb2.3hgd7fb_ujkhfnrxxc3vpxa___1872810511%20%e6%8b%b7%e8%b4%9d%202c.png?crc=269053170" alt="" width="371" height="171"/>
         </div>
         <div class="layer49 clip_frame grpelem" id="u860"><!-- image -->
          <img class="block" id="u860_img" src="images/%e6%9c%aa%e6%a0%87%e9%a2%98-3-%e7%9f%a2%e9%87%8f%e6%99%ba%e8%83%bd%e5%af%b9%e8%b1%a1c.png?crc=508099795" alt="" width="53" height="33"/>
         </div>
         <div class="layer48 clip_frame grpelem" id="u853"><!-- image -->
          <img class="block" id="u853_img" src="images/%e6%9c%aa%e6%a0%87%e9%a2%98-3-%e7%9f%a2%e9%87%8f%e6%99%ba%e8%83%bd%e5%af%b9%e8%b1%a1c2.png?crc=341925865" alt="" width="93" height="66"/>
         </div>
         <div class="layer47 clip_frame grpelem" id="u846"><!-- image -->
          <img class="block" id="u846_img" src="images/%e6%9c%aa%e6%a0%87%e9%a2%98-3-tb2.3hgd7fb_ujkhfnrxxc3vpxa___1872810511%20%e6%8b%b7%e8%b4%9dc.png?crc=153061947" alt="" width="380" height="98"/>
         </div>
         <div class="layer46 clip_frame grpelem" id="u832"><!-- image -->
          <img class="block" id="u832_img" src="images/%e6%9c%aa%e6%a0%87%e9%a2%98-3-tb2rgjld7fb_ujksnavxxxfmvxa___1872810511c.png?crc=343277746" alt="" width="129" height="191"/>
         </div>
         <div class="layer45 clip_frame grpelem" id="u825"><!-- image -->
          <img class="block" id="u825_img" src="images/%e6%9c%aa%e6%a0%87%e9%a2%98-3-tb26pwherbm8kjjszffxxaynpxa___1872810511c.png?crc=3954900069" alt="" width="157" height="190"/>
         </div>
         <div class="layer44 clip_frame grpelem" id="u818"><!-- image -->
          <img class="block" id="u818_img" src="images/%e6%9c%aa%e6%a0%87%e9%a2%98-3-tb2pgnad7fb_ujksne1xxbe4xxa___1872810511c.png?crc=3957992381" alt="" width="105" height="83"/>
         </div>
         <div class="layer43 clip_frame grpelem" id="u811"><!-- image -->
          <img class="block" id="u811_img" src="images/%e6%9c%aa%e6%a0%87%e9%a2%98-3-tb2ltkfetfn8kjjszfjxxxgvpxa___1872810511c.png?crc=3831090245" alt="" width="88" height="84"/>
         </div>
         <div class="clip_frame grpelem" id="u895"><!-- image -->
          <img class="block" id="u895_img" src="images/%e6%9c%aa%e6%a0%87%e9%a2%98-3-tb2xv6incbi8kjjy1zdxxbe1vxa___1872810511c.png?crc=3786668666" alt="" width="114" height="115"/>
         </div>
         <div class="clip_frame grpelem" id="u797"><!-- image -->
          <img class="block" id="u797_img" src="images/%e6%9c%aa%e6%a0%87%e9%a2%98-3-%e7%9f%a2%e9%87%8f%e6%99%ba%e8%83%bd%e5%af%b9%e8%b1%a1c3.png?crc=4137711774" alt="" width="90" height="54"/>
         </div>
        </div>
        <div class="clearfix grpelem" id="pu867"><!-- group -->
         <div class="clip_frame grpelem" id="u867"><!-- image -->
          <img class="block" id="u867_img" src="images/%e6%9c%aa%e6%a0%87%e9%a2%98-3-%e7%9f%a2%e9%87%8f%e6%99%ba%e8%83%bd%e5%af%b9%e8%b1%a1c4.png?crc=168254248" alt="" width="66" height="37"/>
         </div>
         <div class="layer42 clip_frame grpelem" id="u804"><!-- image -->
          <img class="block" id="u804_img" src="images/%e6%9c%aa%e6%a0%87%e9%a2%98-3-tb2.3hgd7fb_ujkhfnrxxc3vpxa___1872810511%20%e6%8b%b7%e8%b4%9d%203c.png?crc=465499623" alt="" width="341" height="158"/>
         </div>
        </div>
       </div>
      </div>
     </div>
    </div>
    <div class="clearfix colelem" id="pu1088"><!-- group -->
     <div class="browser_width grpelem" id="u1088-bw">
      <div class="museBGSize scene5" id="u1088"><!-- group -->
       <div class="clearfix" id="u1088_align_to_page">
        <div class="clearfix grpelem" id="u1067"><!-- group -->
         <div class="layer55 clip_frame grpelem" id="u1053"><!-- image -->
          <img class="block" id="u1053_img" src="images/%e6%9c%aa%e6%a0%87%e9%a2%98-2-tb2orplnhpi8kjjsspfxxccfxxa___1872810511c.png?crc=162566771" alt="" width="172" height="177"/>
         </div>
         <div class="layer54 clip_frame grpelem" id="u1046"><!-- image -->
          <img class="block" id="u1046_img" src="images/%e6%9c%aa%e6%a0%87%e9%a2%98-2-%e5%9b%be%e5%b1%82%201c.png?crc=4082437268" alt="" width="473" height="242"/>
         </div>
         <div class="layer53 clip_frame grpelem" id="u1039"><!-- image -->
          <img class="block" id="u1039_img" src="images/%e6%9c%aa%e6%a0%87%e9%a2%98-2-%e5%ba%97%e9%93%ba%20(1)c.png?crc=3986711495" alt="" width="316" height="163"/>
         </div>
         <div class="layer52 clip_frame grpelem" id="u1032"><!-- image -->
          <img class="block" id="u1032_img" src="images/%e6%9c%aa%e6%a0%87%e9%a2%98-2-%e5%9b%be%e5%b1%82%202c.png?crc=4185871850" alt="" width="446" height="233"/>
         </div>
         <div class="clip_frame grpelem" id="u1025"><!-- image -->
          <img class="block" id="u1025_img" src="images/%e6%9c%aa%e6%a0%87%e9%a2%98-2-%e5%9b%be%e5%b1%82%203c.png?crc=4193959528" alt="" width="1200" height="232"/>
         </div>
        </div>
       </div>
      </div>
     </div>
     <div class="size_fixed grpelem" id="u970"><!-- custom html -->
      

     </div>
    </div>
    <div class="size_fixed colelem" id="u1009"><!-- custom html -->
     

    </div>
    <div class="clearfix colelem" id="u1101-5"><!-- content -->
     <p id="u1101-2">&nbsp;⬆️依次为：熊文化 &gt; 熊宣言&nbsp; &gt; 熊宝藏 &gt; 熊战队 &gt; 熊小店</p>
     <p>&nbsp;</p>
    </div>
    <div class="clearfix colelem" id="pu1104"><!-- group -->
     <div class="size_fixed grpelem" id="u1104"><!-- custom html -->
      

     </div>
     <div class="size_fixed grpelem" id="u1109"><!-- custom html -->
      
<!-- Slider main container -->
<div class="swiper-container1">
    <!-- Additional required wrapper -->
    <div class="swiper-wrapper" id="sls1">
    </div>
    <!-- If we need pagination -->
    <div class="swiper-pagination"></div>
    <!-- If we need scrollbar -->
    <div class="swiper-null"></div>
</div>

     </div>
    </div>
    <div class="clearfix colelem" id="pu1161"><!-- group -->
     <div class="transition museBGSize grpelem" id="u1161"><!-- simple frame --></div>
     <div class="transition museBGSize grpelem" id="u1185"><!-- simple frame --></div>
     <div class="transition museBGSize grpelem" id="u1193"><!-- simple frame --></div>
    </div>
    <div class="clearfix colelem" id="u1231-29"><!-- content -->
     <p>⬆️以上3图可交互</p>
     <p>&nbsp;</p>
     <p>&nbsp;</p>
     <p>&nbsp;</p>
     <p>&nbsp;</p>
     <p>&nbsp;</p>
     <p>&nbsp;</p>
     <p>&nbsp;</p>
     <p>&nbsp;</p>
     <p>&nbsp;</p>
     <p>&nbsp;</p>
     <p>&nbsp;</p>
     <p>&nbsp;</p>
     <p>&nbsp;</p>
     <p>&nbsp;</p>
     <p>&nbsp;</p>
     <p>Day1-3:先完成制作内页风格设计，提交至甲方并根据意见小内容修改</p>
     <p>&nbsp;</p>
     <p>Day4-7:内页风格的设计得到确认后开始首页稿的设计，根据提供的首页内容与参考网站（三只松鼠），与对方交接人交流确认方向，以首屏的视觉导向工厂流水线，拟讲故事的方式给用户呈现网站首页的画面</p>
     <p>&nbsp;</p>
     <p>Day8-9:修改首页三模块形象小图，完成。⬇️</p>
     <p>&nbsp;</p>
     <p>&nbsp;</p>
    </div>
    <div class="clip_frame colelem" id="u1234"><!-- image -->
     <img class="block" id="u1234_img" src="images/web_01.png?crc=4159525624" alt="" width="1350" height="1055"/>
    </div>
    <div class="clip_frame colelem" id="u1244"><!-- image -->
     <img class="block" id="u1244_img" src="images/web_02.png?crc=394432326" alt="" width="1350" height="1055"/>
    </div>
    <div class="clip_frame colelem" id="u1254"><!-- image -->
     <img class="block" id="u1254_img" src="images/web_03.png?crc=199094009" alt="" width="1350" height="1055"/>
    </div>
    <div class="clip_frame colelem" id="u1264"><!-- image -->
     <img class="block" id="u1264_img" src="images/logo.png?crc=410603061" alt="" width="404" height="402"/>
    </div>
   </div>
  </div>
  <div class="preload_images">
   <img class="preload" src="images/1-2.png?crc=329865755" alt=""/>
   <img class="preload" src="images/2-2.png?crc=190317510" alt=""/>
   <img class="preload" src="images/3-2.png?crc=3976258995" alt=""/>
  </div>
  <!-- JS includes -->
  <script type="text/javascript">
   if (document.location.protocol != 'https:') document.write('\x3Cscript src="http://musecdn.businesscatalyst.com/scripts/4.0/jquery-1.8.3.min.js" type="text/javascript">\x3C/script>');
</script>
  <script type="text/javascript">
   window.jQuery || document.write('\x3Cscript src="scripts/jquery-1.8.3.min.js?crc=209076791" type="text/javascript">\x3C/script>');
</script>
  <!-- Other scripts -->
  <script type="text/javascript">
   // Decide whether to suppress missing file error or not based on preference setting
var suppressMissingFileError = false
</script>
  <script type="text/javascript">
   window.Muse.assets.check=function(c){if(!window.Muse.assets.checked){window.Muse.assets.checked=!0;var b={},d=function(a,b){if(window.getComputedStyle){var c=window.getComputedStyle(a,null);return c&&c.getPropertyValue(b)||c&&c[b]||""}if(document.documentElement.currentStyle)return(c=a.currentStyle)&&c[b]||a.style&&a.style[b]||"";return""},a=function(a){if(a.match(/^rgb/))return a=a.replace(/\s+/g,"").match(/([\d\,]+)/gi)[0].split(","),(parseInt(a[0])<<16)+(parseInt(a[1])<<8)+parseInt(a[2]);if(a.match(/^\#/))return parseInt(a.substr(1),
16);return 0},f=function(f){for(var g=document.getElementsByTagName("link"),j=0;j<g.length;j++)if("text/css"==g[j].type){var l=(g[j].href||"").match(/\/?css\/([\w\-]+\.css)\?crc=(\d+)/);if(!l||!l[1]||!l[2])break;b[l[1]]=l[2]}g=document.createElement("div");g.className="version";g.style.cssText="display:none; width:1px; height:1px;";document.getElementsByTagName("body")[0].appendChild(g);for(j=0;j<Muse.assets.required.length;){var l=Muse.assets.required[j],k=l.match(/([\w\-\.]+)\.(\w+)$/),i=k&&k[1]?
k[1]:null,k=k&&k[2]?k[2]:null;switch(k.toLowerCase()){case "css":i=i.replace(/\W/gi,"_").replace(/^([^a-z])/gi,"_$1");g.className+=" "+i;i=a(d(g,"color"));k=a(d(g,"backgroundColor"));i!=0||k!=0?(Muse.assets.required.splice(j,1),"undefined"!=typeof b[l]&&(i!=b[l]>>>24||k!=(b[l]&16777215))&&Muse.assets.outOfDate.push(l)):j++;g.className="version";break;case "js":j++;break;default:throw Error("Unsupported file type: "+k);}}c?c().jquery!="1.8.3"&&Muse.assets.outOfDate.push("jquery-1.8.3.min.js"):Muse.assets.required.push("jquery-1.8.3.min.js");
g.parentNode.removeChild(g);if(Muse.assets.outOfDate.length||Muse.assets.required.length)g="服务器上的某些文件可能缺失或不正确。请在清除浏览器高速缓存后重试。如果问题仍然存在，请联系网站作者。",f&&Muse.assets.outOfDate.length&&(g+="\nOut of date: "+Muse.assets.outOfDate.join(",")),f&&Muse.assets.required.length&&(g+="\nMissing: "+Muse.assets.required.join(",")),suppressMissingFileError?(g+="\nUse SuppressMissingFileError key in AppPrefs.xml to show missing file error pop up.",console.log(g)):alert(g)};location&&location.search&&location.search.match&&location.search.match(/muse_debug/gi)?
setTimeout(function(){f(!0)},5E3):f()}};
var muse_init=function(){require.config({baseUrl:""});require(["jquery","museutils","whatinput","jquery.musepolyfill.bgsize","jquery.watch"],function(c){var $ = c;$(document).ready(function(){try{
window.Muse.assets.check($);/* body */
Muse.Utils.transformMarkupToFixBrowserProblemsPreInit();/* body */
Muse.Utils.prepHyperlinks(true);/* body */
Muse.Utils.resizeHeight('.browser_width');/* resize height */
Muse.Utils.requestAnimationFrame(function() { $('body').addClass('initialized'); });/* mark body as initialized */
(function(){
	try{

$(document).ready(function(){if(3==2){document.getElementById('sls1').innerHTML="<div class='swiper-slide'><a href='#' target='_self'  ><img src='assets/p1.png' alt='alternative text'/></a></div><div class='swiper-slide'><a href='#' target='_self'  ><img src='assets/p2.png' alt='alternative text'/></a></div>"}
else if(3==3){document.getElementById('sls1').innerHTML="<div class='swiper-slide'><a href='#' target='_self'  ><img src='assets/p1.png' alt='alternative text'/></a></div><div class='swiper-slide'><a href='#' target='_self'  ><img src='assets/p2.png' alt='alternative text'/></a></div><div class='swiper-slide'><a href='#' target='_self'  ><img src='assets/p3.png' alt='alternative text'/></a></div>"}
else if(3==4){document.getElementById('sls1').innerHTML="<div class='swiper-slide'><a href='#' target='_self'  ><img src='assets/p1.png' alt='alternative text'/></a></div><div class='swiper-slide'><a href='#' target='_self'  ><img src='assets/p2.png' alt='alternative text'/></a></div><div class='swiper-slide'><a href='#' target='_self'  ><img src='assets/p3.png' alt='alternative text'/></a></div><div class='swiper-slide'><a href='#' target='_self'  ><img src='Add File' alt='alternative text'/></a></div>"}
else if(3==5){document.getElementById('sls1').innerHTML="<div class='swiper-slide'><a href='#' target='_self'  ><img src='assets/p1.png' alt='alternative text'/></a></div><div class='swiper-slide'><a href='#' target='_self'  ><img src='assets/p2.png' alt='alternative text'/></a></div><div class='swiper-slide'><a href='#' target='_self'  ><img src='assets/p3.png' alt='alternative text'/></a></div><div class='swiper-slide'><a href='#' target='_self'  ><img src='Add File' alt='alternative text'/></a></div><div class='swiper-slide'><a href='#' target='_self'  ><img src='Add File' alt='alternative text'/></a></div>"}
else if(3==6){document.getElementById('sls1').innerHTML="<div class='swiper-slide'><a href='#' target='_self'  ><img src='assets/p1.png' alt='alternative text'/></a></div><div class='swiper-slide'><a href='#' target='_self'  ><img src='assets/p2.png' alt='alternative text'/></a></div><div class='swiper-slide'><a href='#' target='_self'  ><img src='assets/p3.png' alt='alternative text'/></a></div><div class='swiper-slide'><a href='#' target='_self'  ><img src='Add File' alt='alternative text'/></a></div><div class='swiper-slide'><a href='#' target='_self'  ><img src='Add File' alt='alternative text'/></a></div><div class='swiper-slide'><a href='#' target='_self'  ><img src='Add File' alt='alternative text'/></a></div>"}
else if(3==7){document.getElementById('sls1').innerHTML="<div class='swiper-slide'><a href='#' target='_self'  ><img src='assets/p1.png' alt='alternative text'/></a></div><div class='swiper-slide'><a href='#' target='_self'  ><img src='assets/p2.png' alt='alternative text'/></a></div><div class='swiper-slide'><a href='#' target='_self'  ><img src='assets/p3.png' alt='alternative text'/></a></div><div class='swiper-slide'><a href='#' target='_self'  ><img src='Add File' alt='alternative text'/></a></div><div class='swiper-slide'><a href='#' target='_self'  ><img src='Add File' alt='alternative text'/></a></div><div class='swiper-slide'><a href='#' target='_self'  ><img src='Add File' alt='alternative text'/></a></div><div class='swiper-slide'><a href='#' target='_self'  ><img src='Add File' alt='alternative text'/></a></div>"}
else if(3==8){document.getElementById('sls1').innerHTML="<div class='swiper-slide'><a href='#' target='_self'  ><img src='assets/p1.png' alt='alternative text'/></a></div><div class='swiper-slide'><a href='#' target='_self'  ><img src='assets/p2.png' alt='alternative text'/></a></div><div class='swiper-slide'><a href='#' target='_self'  ><img src='assets/p3.png' alt='alternative text'/></a></div><div class='swiper-slide'><a href='#' target='_self'  ><img src='Add File' alt='alternative text'/></a></div><div class='swiper-slide'><a href='#' target='_self'  ><img src='Add File' alt='alternative text'/></a></div><div class='swiper-slide'><a href='#' target='_self'  ><img src='Add File' alt='alternative text'/></a></div><div class='swiper-slide'><a href='#' target='_self'  ><img src='Add File' alt='alternative text'/></a></div><div class='swiper-slide'><a href='#' target='_self'  ><img src='Add File' alt='alternative text'/></a></div>"}
else if(3==9){document.getElementById('sls1').innerHTML="<div class='swiper-slide'><a href='#' target='_self'  ><img src='assets/p1.png' alt='alternative text'/></a></div><div class='swiper-slide'><a href='#' target='_self'  ><img src='assets/p2.png' alt='alternative text'/></a></div><div class='swiper-slide'><a href='#' target='_self'  ><img src='assets/p3.png' alt='alternative text'/></a></div><div class='swiper-slide'><a href='#' target='_self'  ><img src='Add File' alt='alternative text'/></a></div><div class='swiper-slide'><a href='#' target='_self'  ><img src='Add File' alt='alternative text'/></a></div><div class='swiper-slide'><a href='#' target='_self'  ><img src='Add File' alt='alternative text'/></a></div><div class='swiper-slide'><a href='#' target='_self'  ><img src='Add File' alt='alternative text'/></a></div><div class='swiper-slide'><a href='#' target='_self'  ><img src='Add File' alt='alternative text'/></a></div><div class='swiper-slide'><a href='#' target='_self'  ><img src='Add File' alt='alternative text'/></a></div>"}
else if(3==10){document.getElementById('sls1').innerHTML="<div class='swiper-slide'><a href='#' target='_self'  ><img src='assets/p1.png' alt='alternative text'/></a></div><div class='swiper-slide'><a href='#' target='_self'  ><img src='assets/p2.png' alt='alternative text'/></a></div><div class='swiper-slide'><a href='#' target='_self'  ><img src='assets/p3.png' alt='alternative text'/></a></div><div class='swiper-slide'><a href='#' target='_self'  ><img src='Add File' alt='alternative text'/></a></div><div class='swiper-slide'><a href='#' target='_self'  ><img src='Add File' alt='alternative text'/></a></div><div class='swiper-slide'><a href='#' target='_self'  ><img src='Add File' alt='alternative text'/></a></div><div class='swiper-slide'><a href='#' target='_self'  ><img src='Add File' alt='alternative text'/></a></div><div class='swiper-slide'><a href='#' target='_self'  ><img src='Add File' alt='alternative text'/></a></div><div class='swiper-slide'><a href='#' target='_self'  ><img src='Add File' alt='alternative text'/></a></div><div class='swiper-slide'><a href='#' target='_self'  ><img src='Add File' alt='alternative text'/></a></div>"}
else if(3==11){document.getElementById('sls1').innerHTML="<div class='swiper-slide'><a href='#' target='_self'  ><img src='assets/p1.png' alt='alternative text'/></a></div><div class='swiper-slide'><a href='#' target='_self'  ><img src='assets/p2.png' alt='alternative text'/></a></div><div class='swiper-slide'><a href='#' target='_self'  ><img src='assets/p3.png' alt='alternative text'/></a></div><div class='swiper-slide'><a href='#' target='_self'  ><img src='Add File' alt='alternative text'/></a></div><div class='swiper-slide'><a href='#' target='_self'  ><img src='Add File' alt='alternative text'/></a></div><div class='swiper-slide'><a href='#' target='_self'  ><img src='Add File' alt='alternative text'/></a></div><div class='swiper-slide'><a href='#' target='_self'  ><img src='Add File' alt='alternative text'/></a></div><div class='swiper-slide'><a href='#' target='_self'  ><img src='Add File' alt='alternative text'/></a></div><div class='swiper-slide'><a href='#' target='_self'  ><img src='Add File' alt='alternative text'/></a></div><div class='swiper-slide'><a href='#' target='_self'  ><img src='Add File' alt='alternative text'/></a></div><div class='swiper-slide'><a href='#' target='_self'  ><img src='Add File' alt='alternative text'/></a></div>"}
else{document.getElementById('sls1').innerHTML="<div class='swiper-slide'><a href='#' target='_self'  ><img src='assets/p1.png' alt='alternative text'/></a></div><div class='swiper-slide'><a href='#' target='_self'  ><img src='assets/p2.png' alt='alternative text'/></a></div><div class='swiper-slide'><a href='#' target='_self'  ><img src='assets/p3.png' alt='alternative text'/></a></div><div class='swiper-slide'><a href='#' target='_self'  ><img src='Add File' alt='alternative text'/></a></div><div class='swiper-slide'><a href='#' target='_self'  ><img src='Add File' alt='alternative text'/></a></div><div class='swiper-slide'><a href='#' target='_self'  ><img src='Add File' alt='alternative text'/></a></div><div class='swiper-slide'><a href='#' target='_self'  ><img src='Add File' alt='alternative text'/></a></div><div class='swiper-slide'><a href='#' target='_self'  ><img src='Add File' alt='alternative text'/></a></div><div class='swiper-slide'><a href='#' target='_self'  ><img src='Add File' alt='alternative text'/></a></div><div class='swiper-slide'><a href='#' target='_self'  ><img src='Add File' alt='alternative text'/></a></div><div class='swiper-slide'><a href='#' target='_self'  ><img src='Add File' alt='alternative text'/></a></div><div class='swiper-slide'><a href='#' target='_self'  ><img src='Add File' alt='alternative text'/></a></div>"}
require(['https://cdn.jsdelivr.net/npm/object-fit-images@3.2.3/dist/ofi.min.js'],function(){var mySwiper=new Swiper('.swiper-container1',{initialSlide:800,direction:'horizontal',speed:1000,grabCursor:true,centeredSlides:!0,slidesPerView:2,breakpoints:{960:{slidesPerView:1,spaceBetween:0},600:{slidesPerView:1,spaceBetween:0},480:{slidesPerView:1,spaceBetween:0},320:{slidesPerView:1,spaceBetween:0}},pagination:{el:'.swiper-pagination',clickable:!0,dynamicBullets:true,dynamicMainBullets:1,type:'progressbar',},navigation:{nextEl:'.next',prevEl:'.prev',hideOnClick:!0},scrollbar:{el:'.swiper-scrollbar',hide:true,draggable:false,snapOnRelease:false},autoplay:{delay:2000,stopOnLastSlide:false,disableOnInteraction:false,reverseDirection:false},freeMode:false,freeModeMomentum:false,freeModeMomentumRatio:1,freeModeMomentumVelocityRatio:1,freeModeMomentumBounce:false,freeModeMomentumBounceRatio:1,freeModeMinimumVelocity:0.02,freeModeSticky:false,effect:'slide',fadeEffect:{crossFade:false},cubeEffect:{slideShadows:false,shadow:false,shadowOffset:20,shadowScale:0.94},coverflowEffect:{rotate:50,stretch:0,depth:20,modifier:1,slideShadows:true},flipEffect:{slideShadows:true,limitRotation:true},spaceBetween:100,centeredSlides:false,slidesOffsetBefore:200,slidesOffsetAfter:200,touchRatio:1,touchAngle:45,simulateTouch:true,shortSwipes:true,longSwipes:true,longSwipesRatio:0.5,longSwipesMs:300,followFinger:true,onlyExternal:false,threshold:0,touchMoveStopPropagation:true,iOSEdgeSwipeDetection:false,iOSEdgeSwipeThreshold:20,touchReleaseOnEdges:false,passiveListeners:true,resistance:true,resistanceRatio:0.85,slideToClickedSlide:false,allowSwipeToPrev:true,allowSwipeToNext:true,keyboard:true,mousewheel:{forceToAxis:false,releaseOnEdges:false,invert:false,sensitivity:1},preloadImages:true,updateOnImagesReady:true,loop:true})
//mySwiper.autoplay.stop();
 mySwiper.mousewheel.disable();
var $swprImages = $('.swiper-wrapper img');objectFitImages($swprImages);});});

	}
	catch(e)
	{
		Muse.Assert.fail('Error with Widget:Swiper.js Slideshow for Adobe Muse (1.3) ParamHTMLOnDocReady Handler ' + e.toString());
	}
})();/* Widget:Swiper.js Slideshow for Adobe Muse (1.3) */
Muse.Utils.makeButtonsVisibleAfterSettingMinWidth();/* body */
Muse.Utils.showWidgetsWhenReady();/* body */
Muse.Utils.transformMarkupToFixBrowserProblems();/* body */
}catch(b){if(b&&"function"==typeof b.notify?b.notify():Muse.Assert.fail("Error calling selector function: "+b),false)throw b;}})})};

</script>
  <!-- RequireJS script -->
  <script src="scripts/require.js?crc=7928878" type="text/javascript" async data-main="scripts/museconfig.js?crc=4286661555" onload="if (requirejs) requirejs.onError = function(requireType, requireModule) { if (requireType && requireType.toString && requireType.toString().indexOf && 0 <= requireType.toString().indexOf('#scripterror')) window.Muse.assets.check(); }" onerror="window.Muse.assets.check();"></script>
  
  <!--HTML Widget code-->
  
<script>
$(function() {
  var $body = $(document);
  $body.bind('scroll', function() {
      if ($body.scrollLeft() !== 0) {
          $body.scrollLeft(0);
      }
  });
});
</script>

<script src="https://cdn.jsdelivr.net/jquery.typed.js/1.1.4/typed.min.js"></script>

<script>
$(".scene1").wrap("<ul id='scene1' class='scene'></ul>");
$(".layer1").wrap("<li class='layer' data-depth='1.00'></li>");
$(".layer2").wrap("<li class='layer' data-depth='0.20'></li>");
$(".layer3").wrap("<li class='layer' data-depth='0.40'></li>");
$(".layer4").wrap("<li class='layer' data-depth='0.60'></li>");
$(".layer5").wrap("<li class='layer' data-depth='0.80'></li>");
$(".layer6").wrap("<li class='layer' data-depth='1.00'></li>");
$(".layer7").wrap("<li class='layer' data-depth='1.00'></li>");
$(".layer8").wrap("<li class='layer' data-depth='0.20'></li>");
$(".layer9").wrap("<li class='layer' data-depth='0.40'></li>");
$(".layer10").wrap("<li class='layer' data-depth='0.60'></li>");
$(".layer11").wrap("<li class='layer' data-depth='0.80'></li>");
$(".layer12").wrap("<li class='layer' data-depth='1.00'></li>");
</script>
<script>
//============================================================
//
// The MIT License
//
// Copyright (C) 2014 Matthew Wagerfield - @wagerfield
//
// Permission is hereby granted, free of charge, to any
// person obtaining a copy of this software and associated
// documentation files (the "Software"), to deal in the
// Software without restriction, including without limitation
// the rights to use, copy, modify, merge, publish, distribute,
// sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do
// so, subject to the following conditions:
//
// The above copyright notice and this permission notice
// shall be included in all copies or substantial portions
// of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY
// OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
// LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
// EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
// AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
// OR OTHER DEALINGS IN THE SOFTWARE.
//
//============================================================

/**
 * Parallax.js
 * @author Matthew Wagerfield - @wagerfield
 * @description Creates a parallax effect between an array of layers,
 *              driving the motion from the gyroscope output of a smartdevice.
 *              If no gyroscope is available, the cursor position is used.
 */
;(function(window, document, undefined) {

  // Strict Mode
  'use strict';

  // Constants
  var NAME = 'Parallax';
  var MAGIC_NUMBER = 30;
  var DEFAULTS = {
    relativeInput: false,
    clipRelativeInput: false,
    calibrationThreshold: 100,
    calibrationDelay: 500,
    supportDelay: 500,
    calibrateX: false,
    calibrateY: true,
    invertX: true,
    invertY: true,
    limitX: false,
    limitY: false,
    scalarX: 10.0,
    scalarY: 10.0,
    frictionX: 0.1,
    frictionY: 0.1,
    originX: 0.5,
    originY: 0.5
  };

  function Parallax(element, options) {

    // DOM Context
    this.element = element;
    this.layers = element.getElementsByClassName('layer');

    // Data Extraction
    var data = {
      calibrateX: this.data(this.element, 'calibrate-x'),
      calibrateY: this.data(this.element, 'calibrate-y'),
      invertX: this.data(this.element, 'invert-x'),
      invertY: this.data(this.element, 'invert-y'),
      limitX: this.data(this.element, 'limit-x'),
      limitY: this.data(this.element, 'limit-y'),
      scalarX: this.data(this.element, 'scalar-x'),
      scalarY: this.data(this.element, 'scalar-y'),
      frictionX: this.data(this.element, 'friction-x'),
      frictionY: this.data(this.element, 'friction-y'),
      originX: this.data(this.element, 'origin-x'),
      originY: this.data(this.element, 'origin-y')
    };

    // Delete Null Data Values
    for (var key in data) {
      if (data[key] === null) delete data[key];
    }

    // Compose Settings Object
    this.extend(this, DEFAULTS, options, data);

    // States
    this.calibrationTimer = null;
    this.calibrationFlag = true;
    this.enabled = false;
    this.depths = [];
    this.raf = null;

    // Element Bounds
    this.bounds = null;
    this.ex = 0;
    this.ey = 0;
    this.ew = 0;
    this.eh = 0;

    // Element Center
    this.ecx = 0;
    this.ecy = 0;

    // Element Range
    this.erx = 0;
    this.ery = 0;

    // Calibration
    this.cx = 0;
    this.cy = 0;

    // Input
    this.ix = 0;
    this.iy = 0;

    // Motion
    this.mx = 0;
    this.my = 0;

    // Velocity
    this.vx = 0;
    this.vy = 0;

    // Callbacks
    this.onMouseMove = this.onMouseMove.bind(this);
    this.onDeviceOrientation = this.onDeviceOrientation.bind(this);
    this.onOrientationTimer = this.onOrientationTimer.bind(this);
    this.onCalibrationTimer = this.onCalibrationTimer.bind(this);
    this.onAnimationFrame = this.onAnimationFrame.bind(this);
    this.onWindowResize = this.onWindowResize.bind(this);

    // Initialise
    this.initialise();
  }

  Parallax.prototype.extend = function() {
    if (arguments.length > 1) {
      var master = arguments[0];
      for (var i = 1, l = arguments.length; i < l; i++) {
        var object = arguments[i];
        for (var key in object) {
          master[key] = object[key];
        }
      }
    }
  };

  Parallax.prototype.data = function(element, name) {
    return this.deserialize(element.getAttribute('data-'+name));
  };

  Parallax.prototype.deserialize = function(value) {
    if (value === 'true') {
      return true;
    } else if (value === 'false') {
      return false;
    } else if (value === 'null') {
      return null;
    } else if (!isNaN(parseFloat(value)) && isFinite(value)) {
      return parseFloat(value);
    } else {
      return value;
    }
  };

  Parallax.prototype.camelCase = function(value) {
    return value.replace(/-+(.)?/g, function(match, character){
      return character ? character.toUpperCase() : '';
    });
  };

  Parallax.prototype.transformSupport = function(value) {
    var element = document.createElement('div');
    var propertySupport = false;
    var propertyValue = null;
    var featureSupport = false;
    var cssProperty = null;
    var jsProperty = null;
    for (var i = 0, l = this.vendors.length; i < l; i++) {
      if (this.vendors[i] !== null) {
        cssProperty = this.vendors[i][0] + 'transform';
        jsProperty = this.vendors[i][1] + 'Transform';
      } else {
        cssProperty = 'transform';
        jsProperty = 'transform';
      }
      if (element.style[jsProperty] !== undefined) {
        propertySupport = true;
        break;
      }
    }
    switch(value) {
      case '2D':
        featureSupport = propertySupport;
        break;
      case '3D':
        if (propertySupport) {
          var body = document.body || document.createElement('body');
          var documentElement = document.documentElement;
          var documentOverflow = documentElement.style.overflow;
          if (!document.body) {
            documentElement.style.overflow = 'hidden';
            documentElement.appendChild(body);
            body.style.overflow = 'hidden';
            body.style.background = '';
          }
          body.appendChild(element);
          element.style[jsProperty] = 'translate3d(1px,1px,1px)';
          propertyValue = window.getComputedStyle(element).getPropertyValue(cssProperty);
          featureSupport = propertyValue !== undefined && propertyValue.length > 0 && propertyValue !== 'none';
          documentElement.style.overflow = documentOverflow;
          body.removeChild(element);
        }
        break;
    }
    return featureSupport;
  };

  Parallax.prototype.ww = null;
  Parallax.prototype.wh = null;
  Parallax.prototype.wcx = null;
  Parallax.prototype.wcy = null;
  Parallax.prototype.wrx = null;
  Parallax.prototype.wry = null;
  Parallax.prototype.portrait = null;
  Parallax.prototype.desktop = !navigator.userAgent.match(/(iPhone|iPod|iPad|Android|BlackBerry|BB10|mobi|tablet|opera mini|nexus 7)/i);
  Parallax.prototype.vendors = [null,['-webkit-','webkit'],['-moz-','Moz'],['-o-','O'],['-ms-','ms']];
  Parallax.prototype.motionSupport = !!window.DeviceMotionEvent;
  Parallax.prototype.orientationSupport = !!window.DeviceOrientationEvent;
  Parallax.prototype.orientationStatus = 0;
  Parallax.prototype.propertyCache = {};

  Parallax.prototype.initialise = function() {

    if (Parallax.prototype.transform2DSupport === undefined) {
      Parallax.prototype.transform2DSupport = Parallax.prototype.transformSupport('2D');
      Parallax.prototype.transform3DSupport = Parallax.prototype.transformSupport('3D');
    }

    // Configure Context Styles
    if (this.transform3DSupport) this.accelerate(this.element);
    var style = window.getComputedStyle(this.element);
    if (style.getPropertyValue('position') === 'static') {
      this.element.style.position = 'relative';
    }

    // Setup
    this.updateLayers();
    this.updateDimensions();
    this.enable();
    this.queueCalibration(this.calibrationDelay);
  };

  Parallax.prototype.updateLayers = function() {

    // Cache Layer Elements
    this.layers = this.element.getElementsByClassName('layer');
    this.depths = [];

    // Configure Layer Styles
    for (var i = 0, l = this.layers.length; i < l; i++) {
      var layer = this.layers[i];
      if (this.transform3DSupport) this.accelerate(layer);

      // Cache Layer Depth
      this.depths.push(this.data(layer, 'depth') || 0);
    }
  };

  Parallax.prototype.updateDimensions = function() {
    this.ww = window.innerWidth;
    this.wh = window.innerHeight;
    this.wcx = this.ww * this.originX;
    this.wcy = this.wh * this.originY;
    this.wrx = Math.max(this.wcx, this.ww - this.wcx);
    this.wry = Math.max(this.wcy, this.wh - this.wcy);
  };

  Parallax.prototype.updateBounds = function() {
    this.bounds = this.element.getBoundingClientRect();
    this.ex = this.bounds.left;
    this.ey = this.bounds.top;
    this.ew = this.bounds.width;
    this.eh = this.bounds.height;
    this.ecx = this.ew * this.originX;
    this.ecy = this.eh * this.originY;
    this.erx = Math.max(this.ecx, this.ew - this.ecx);
    this.ery = Math.max(this.ecy, this.eh - this.ecy);
  };

  Parallax.prototype.queueCalibration = function(delay) {
    clearTimeout(this.calibrationTimer);
    this.calibrationTimer = setTimeout(this.onCalibrationTimer, delay);
  };

  Parallax.prototype.enable = function() {
    if (!this.enabled) {
      this.enabled = true;
      if (this.orientationSupport) {
        this.portrait = null;
        window.addEventListener('deviceorientation', this.onDeviceOrientation);
        setTimeout(this.onOrientationTimer, this.supportDelay);
      } else {
        this.cx = 0;
        this.cy = 0;
        this.portrait = false;
        window.addEventListener('mousemove', this.onMouseMove);
      }
      window.addEventListener('resize', this.onWindowResize);
      this.raf = requestAnimationFrame(this.onAnimationFrame);
    }
  };

  Parallax.prototype.disable = function() {
    if (this.enabled) {
      this.enabled = false;
      if (this.orientationSupport) {
        window.removeEventListener('deviceorientation', this.onDeviceOrientation);
      } else {
        window.removeEventListener('mousemove', this.onMouseMove);
      }
      window.removeEventListener('resize', this.onWindowResize);
      cancelAnimationFrame(this.raf);
    }
  };

  Parallax.prototype.calibrate = function(x, y) {
    this.calibrateX = x === undefined ? this.calibrateX : x;
    this.calibrateY = y === undefined ? this.calibrateY : y;
  };

  Parallax.prototype.invert = function(x, y) {
    this.invertX = x === undefined ? this.invertX : x;
    this.invertY = y === undefined ? this.invertY : y;
  };

  Parallax.prototype.friction = function(x, y) {
    this.frictionX = x === undefined ? this.frictionX : x;
    this.frictionY = y === undefined ? this.frictionY : y;
  };

  Parallax.prototype.scalar = function(x, y) {
    this.scalarX = x === undefined ? this.scalarX : x;
    this.scalarY = y === undefined ? this.scalarY : y;
  };

  Parallax.prototype.limit = function(x, y) {
    this.limitX = x === undefined ? this.limitX : x;
    this.limitY = y === undefined ? this.limitY : y;
  };

  Parallax.prototype.origin = function(x, y) {
    this.originX = x === undefined ? this.originX : x;
    this.originY = y === undefined ? this.originY : y;
  };

  Parallax.prototype.clamp = function(value, min, max) {
    value = Math.max(value, min);
    value = Math.min(value, max);
    return value;
  };

  Parallax.prototype.css = function(element, property, value) {
    var jsProperty = this.propertyCache[property];
    if (!jsProperty) {
      for (var i = 0, l = this.vendors.length; i < l; i++) {
        if (this.vendors[i] !== null) {
          jsProperty = this.camelCase(this.vendors[i][1] + '-' + property);
        } else {
          jsProperty = property;
        }
        if (element.style[jsProperty] !== undefined) {
          this.propertyCache[property] = jsProperty;
          break;
        }
      }
    }
    element.style[jsProperty] = value;
  };

  Parallax.prototype.accelerate = function(element) {
    this.css(element, 'transform', 'translate3d(0,0,0)');
    this.css(element, 'transform-style', 'preserve-3d');
    this.css(element, 'backface-visibility', 'hidden');
  };

  Parallax.prototype.setPosition = function(element, x, y) {
    x += 'px';
    y += 'px';
    if (this.transform3DSupport) {
      this.css(element, 'transform', 'translate3d('+x+','+y+',0)');
    } else if (this.transform2DSupport) {
      this.css(element, 'transform', 'translate('+x+','+y+')');
    } else {
      element.style.left = x;
      element.style.top = y;
    }
  };

  Parallax.prototype.onOrientationTimer = function() {
    if (this.orientationSupport && this.orientationStatus === 0) {
      this.disable();
      this.orientationSupport = false;
      this.enable();
    }
  };

  Parallax.prototype.onCalibrationTimer = function() {
    this.calibrationFlag = true;
  };

  Parallax.prototype.onWindowResize = function() {
    this.updateDimensions();
  };

  Parallax.prototype.onAnimationFrame = function() {
    this.updateBounds();
    var dx = this.ix - this.cx;
    var dy = this.iy - this.cy;
    if ((Math.abs(dx) > this.calibrationThreshold) || (Math.abs(dy) > this.calibrationThreshold)) {
      this.queueCalibration(0);
    }
    if (this.portrait) {
      this.mx = this.calibrateX ? dy : this.iy;
      this.my = this.calibrateY ? dx : this.ix;
    } else {
      this.mx = this.calibrateX ? dx : this.ix;
      this.my = this.calibrateY ? dy : this.iy;
    }
    this.mx *= this.ew * (this.scalarX / 100);
    this.my *= this.eh * (this.scalarY / 100);
    if (!isNaN(parseFloat(this.limitX))) {
      this.mx = this.clamp(this.mx, -this.limitX, this.limitX);
    }
    if (!isNaN(parseFloat(this.limitY))) {
      this.my = this.clamp(this.my, -this.limitY, this.limitY);
    }
    this.vx += (this.mx - this.vx) * this.frictionX;
    this.vy += (this.my - this.vy) * this.frictionY;
    for (var i = 0, l = this.layers.length; i < l; i++) {
      var layer = this.layers[i];
      var depth = this.depths[i];
      var xOffset = this.vx * depth * (this.invertX ? -1 : 1);
      var yOffset = this.vy * depth * (this.invertY ? -1 : 1);
      this.setPosition(layer, xOffset, yOffset);
    }
    this.raf = requestAnimationFrame(this.onAnimationFrame);
  };

  Parallax.prototype.onDeviceOrientation = function(event) {

    // Validate environment and event properties.
    if (!this.desktop && event.beta !== null && event.gamma !== null) {

      // Set orientation status.
      this.orientationStatus = 1;

      // Extract Rotation
      var x = (event.beta  || 0) / MAGIC_NUMBER; //  -90 :: 90
      var y = (event.gamma || 0) / MAGIC_NUMBER; // -180 :: 180

      // Detect Orientation Change
      var portrait = this.wh > this.ww;
      if (this.portrait !== portrait) {
        this.portrait = portrait;
        this.calibrationFlag = true;
      }

      // Set Calibration
      if (this.calibrationFlag) {
        this.calibrationFlag = false;
        this.cx = x;
        this.cy = y;
      }

      // Set Input
      this.ix = x;
      this.iy = y;
    }
  };

  Parallax.prototype.onMouseMove = function(event) {

    // Cache mouse coordinates.
    var clientX = event.clientX;
    var clientY = event.clientY;

    // Calculate Mouse Input
    if (!this.orientationSupport && this.relativeInput) {

      // Clip mouse coordinates inside element bounds.
      if (this.clipRelativeInput) {
        clientX = Math.max(clientX, this.ex);
        clientX = Math.min(clientX, this.ex + this.ew);
        clientY = Math.max(clientY, this.ey);
        clientY = Math.min(clientY, this.ey + this.eh);
      }

      // Calculate input relative to the element.
      this.ix = (clientX - this.ex - this.ecx) / this.erx;
      this.iy = (clientY - this.ey - this.ecy) / this.ery;

    } else {

      // Calculate input relative to the window.
      this.ix = (clientX - this.wcx) / this.wrx;
      this.iy = (clientY - this.wcy) / this.wry;
    }
  };

  // Expose Parallax
  window[NAME] = Parallax;

})(window, document);

/**
 * Request Animation Frame Polyfill.
 * @author Tino Zijdel
 * @author Paul Irish
 * @see https://gist.github.com/paulirish/1579671
 */
;(function() {

  var lastTime = 0;
  var vendors = ['ms', 'moz', 'webkit', 'o'];

  for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
    window.requestAnimationFrame = window[vendors[x]+'RequestAnimationFrame'];
    window.cancelAnimationFrame = window[vendors[x]+'CancelAnimationFrame'] || window[vendors[x]+'CancelRequestAnimationFrame'];
  }

  if (!window.requestAnimationFrame) {
    window.requestAnimationFrame = function(callback, element) {
      var currTime = new Date().getTime();
      var timeToCall = Math.max(0, 16 - (currTime - lastTime));
      var id = window.setTimeout(function() { callback(currTime + timeToCall); },
        timeToCall);
      lastTime = currTime + timeToCall;
      return id;
    };
  }

  if (!window.cancelAnimationFrame) {
    window.cancelAnimationFrame = function(id) {
      clearTimeout(id);
    };
  }

}());
</script>
<script>
var scene1 = document.getElementById('scene1');
var parallax1 = new Parallax(scene1, {
  relativeInput: false,
  clipRelativeInput: false,
  calibrateX: false,
  calibrateY: true,
  invertX: false,
  invertY: true,
  limitX: false,
  limitY: false,
  scalarX: 5,
  scalarY: 5,
  frictionX: 0.8,
  frictionY: 0.8,
  originX: 0.5,
  originY: 0.5
});
</script>

<script>
$(".scene2").wrap("<ul id='scene2' class='scene'></ul>");
$(".layer11").wrap("<li class='layer' data-depth='1.00'></li>");
$(".layer12").wrap("<li class='layer' data-depth='0.20'></li>");
$(".layer13").wrap("<li class='layer' data-depth='0.40'></li>");
$(".layer14").wrap("<li class='layer' data-depth='0.60'></li>");
$(".layer15").wrap("<li class='layer' data-depth='0.80'></li>");
$(".layer16").wrap("<li class='layer' data-depth='1.00'></li>");
$(".layer17").wrap("<li class='layer' data-depth='1.00'></li>");
$(".layer18").wrap("<li class='layer' data-depth='0.20'></li>");
$(".layer19").wrap("<li class='layer' data-depth='0.40'></li>");
$(".layer110").wrap("<li class='layer' data-depth='0.60'></li>");
$(".layer111").wrap("<li class='layer' data-depth='0.80'></li>");
$(".layer112").wrap("<li class='layer' data-depth='1.00'></li>");
</script>
<script>
//============================================================
//
// The MIT License
//
// Copyright (C) 2014 Matthew Wagerfield - @wagerfield
//
// Permission is hereby granted, free of charge, to any
// person obtaining a copy of this software and associated
// documentation files (the "Software"), to deal in the
// Software without restriction, including without limitation
// the rights to use, copy, modify, merge, publish, distribute,
// sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do
// so, subject to the following conditions:
//
// The above copyright notice and this permission notice
// shall be included in all copies or substantial portions
// of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY
// OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
// LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
// EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
// AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
// OR OTHER DEALINGS IN THE SOFTWARE.
//
//============================================================

/**
 * Parallax.js
 * @author Matthew Wagerfield - @wagerfield
 * @description Creates a parallax effect between an array of layers,
 *              driving the motion from the gyroscope output of a smartdevice.
 *              If no gyroscope is available, the cursor position is used.
 */
;(function(window, document, undefined) {

  // Strict Mode
  'use strict';

  // Constants
  var NAME = 'Parallax';
  var MAGIC_NUMBER = 30;
  var DEFAULTS = {
    relativeInput: false,
    clipRelativeInput: false,
    calibrationThreshold: 100,
    calibrationDelay: 500,
    supportDelay: 500,
    calibrateX: false,
    calibrateY: true,
    invertX: true,
    invertY: true,
    limitX: false,
    limitY: false,
    scalarX: 10.0,
    scalarY: 10.0,
    frictionX: 0.1,
    frictionY: 0.1,
    originX: 0.5,
    originY: 0.5
  };

  function Parallax(element, options) {

    // DOM Context
    this.element = element;
    this.layers = element.getElementsByClassName('layer');

    // Data Extraction
    var data = {
      calibrateX: this.data(this.element, 'calibrate-x'),
      calibrateY: this.data(this.element, 'calibrate-y'),
      invertX: this.data(this.element, 'invert-x'),
      invertY: this.data(this.element, 'invert-y'),
      limitX: this.data(this.element, 'limit-x'),
      limitY: this.data(this.element, 'limit-y'),
      scalarX: this.data(this.element, 'scalar-x'),
      scalarY: this.data(this.element, 'scalar-y'),
      frictionX: this.data(this.element, 'friction-x'),
      frictionY: this.data(this.element, 'friction-y'),
      originX: this.data(this.element, 'origin-x'),
      originY: this.data(this.element, 'origin-y')
    };

    // Delete Null Data Values
    for (var key in data) {
      if (data[key] === null) delete data[key];
    }

    // Compose Settings Object
    this.extend(this, DEFAULTS, options, data);

    // States
    this.calibrationTimer = null;
    this.calibrationFlag = true;
    this.enabled = false;
    this.depths = [];
    this.raf = null;

    // Element Bounds
    this.bounds = null;
    this.ex = 0;
    this.ey = 0;
    this.ew = 0;
    this.eh = 0;

    // Element Center
    this.ecx = 0;
    this.ecy = 0;

    // Element Range
    this.erx = 0;
    this.ery = 0;

    // Calibration
    this.cx = 0;
    this.cy = 0;

    // Input
    this.ix = 0;
    this.iy = 0;

    // Motion
    this.mx = 0;
    this.my = 0;

    // Velocity
    this.vx = 0;
    this.vy = 0;

    // Callbacks
    this.onMouseMove = this.onMouseMove.bind(this);
    this.onDeviceOrientation = this.onDeviceOrientation.bind(this);
    this.onOrientationTimer = this.onOrientationTimer.bind(this);
    this.onCalibrationTimer = this.onCalibrationTimer.bind(this);
    this.onAnimationFrame = this.onAnimationFrame.bind(this);
    this.onWindowResize = this.onWindowResize.bind(this);

    // Initialise
    this.initialise();
  }

  Parallax.prototype.extend = function() {
    if (arguments.length > 1) {
      var master = arguments[0];
      for (var i = 1, l = arguments.length; i < l; i++) {
        var object = arguments[i];
        for (var key in object) {
          master[key] = object[key];
        }
      }
    }
  };

  Parallax.prototype.data = function(element, name) {
    return this.deserialize(element.getAttribute('data-'+name));
  };

  Parallax.prototype.deserialize = function(value) {
    if (value === 'true') {
      return true;
    } else if (value === 'false') {
      return false;
    } else if (value === 'null') {
      return null;
    } else if (!isNaN(parseFloat(value)) && isFinite(value)) {
      return parseFloat(value);
    } else {
      return value;
    }
  };

  Parallax.prototype.camelCase = function(value) {
    return value.replace(/-+(.)?/g, function(match, character){
      return character ? character.toUpperCase() : '';
    });
  };

  Parallax.prototype.transformSupport = function(value) {
    var element = document.createElement('div');
    var propertySupport = false;
    var propertyValue = null;
    var featureSupport = false;
    var cssProperty = null;
    var jsProperty = null;
    for (var i = 0, l = this.vendors.length; i < l; i++) {
      if (this.vendors[i] !== null) {
        cssProperty = this.vendors[i][0] + 'transform';
        jsProperty = this.vendors[i][1] + 'Transform';
      } else {
        cssProperty = 'transform';
        jsProperty = 'transform';
      }
      if (element.style[jsProperty] !== undefined) {
        propertySupport = true;
        break;
      }
    }
    switch(value) {
      case '2D':
        featureSupport = propertySupport;
        break;
      case '3D':
        if (propertySupport) {
          var body = document.body || document.createElement('body');
          var documentElement = document.documentElement;
          var documentOverflow = documentElement.style.overflow;
          if (!document.body) {
            documentElement.style.overflow = 'hidden';
            documentElement.appendChild(body);
            body.style.overflow = 'hidden';
            body.style.background = '';
          }
          body.appendChild(element);
          element.style[jsProperty] = 'translate3d(1px,1px,1px)';
          propertyValue = window.getComputedStyle(element).getPropertyValue(cssProperty);
          featureSupport = propertyValue !== undefined && propertyValue.length > 0 && propertyValue !== 'none';
          documentElement.style.overflow = documentOverflow;
          body.removeChild(element);
        }
        break;
    }
    return featureSupport;
  };

  Parallax.prototype.ww = null;
  Parallax.prototype.wh = null;
  Parallax.prototype.wcx = null;
  Parallax.prototype.wcy = null;
  Parallax.prototype.wrx = null;
  Parallax.prototype.wry = null;
  Parallax.prototype.portrait = null;
  Parallax.prototype.desktop = !navigator.userAgent.match(/(iPhone|iPod|iPad|Android|BlackBerry|BB10|mobi|tablet|opera mini|nexus 7)/i);
  Parallax.prototype.vendors = [null,['-webkit-','webkit'],['-moz-','Moz'],['-o-','O'],['-ms-','ms']];
  Parallax.prototype.motionSupport = !!window.DeviceMotionEvent;
  Parallax.prototype.orientationSupport = !!window.DeviceOrientationEvent;
  Parallax.prototype.orientationStatus = 0;
  Parallax.prototype.propertyCache = {};

  Parallax.prototype.initialise = function() {

    if (Parallax.prototype.transform2DSupport === undefined) {
      Parallax.prototype.transform2DSupport = Parallax.prototype.transformSupport('2D');
      Parallax.prototype.transform3DSupport = Parallax.prototype.transformSupport('3D');
    }

    // Configure Context Styles
    if (this.transform3DSupport) this.accelerate(this.element);
    var style = window.getComputedStyle(this.element);
    if (style.getPropertyValue('position') === 'static') {
      this.element.style.position = 'relative';
    }

    // Setup
    this.updateLayers();
    this.updateDimensions();
    this.enable();
    this.queueCalibration(this.calibrationDelay);
  };

  Parallax.prototype.updateLayers = function() {

    // Cache Layer Elements
    this.layers = this.element.getElementsByClassName('layer');
    this.depths = [];

    // Configure Layer Styles
    for (var i = 0, l = this.layers.length; i < l; i++) {
      var layer = this.layers[i];
      if (this.transform3DSupport) this.accelerate(layer);

      // Cache Layer Depth
      this.depths.push(this.data(layer, 'depth') || 0);
    }
  };

  Parallax.prototype.updateDimensions = function() {
    this.ww = window.innerWidth;
    this.wh = window.innerHeight;
    this.wcx = this.ww * this.originX;
    this.wcy = this.wh * this.originY;
    this.wrx = Math.max(this.wcx, this.ww - this.wcx);
    this.wry = Math.max(this.wcy, this.wh - this.wcy);
  };

  Parallax.prototype.updateBounds = function() {
    this.bounds = this.element.getBoundingClientRect();
    this.ex = this.bounds.left;
    this.ey = this.bounds.top;
    this.ew = this.bounds.width;
    this.eh = this.bounds.height;
    this.ecx = this.ew * this.originX;
    this.ecy = this.eh * this.originY;
    this.erx = Math.max(this.ecx, this.ew - this.ecx);
    this.ery = Math.max(this.ecy, this.eh - this.ecy);
  };

  Parallax.prototype.queueCalibration = function(delay) {
    clearTimeout(this.calibrationTimer);
    this.calibrationTimer = setTimeout(this.onCalibrationTimer, delay);
  };

  Parallax.prototype.enable = function() {
    if (!this.enabled) {
      this.enabled = true;
      if (this.orientationSupport) {
        this.portrait = null;
        window.addEventListener('deviceorientation', this.onDeviceOrientation);
        setTimeout(this.onOrientationTimer, this.supportDelay);
      } else {
        this.cx = 0;
        this.cy = 0;
        this.portrait = false;
        window.addEventListener('mousemove', this.onMouseMove);
      }
      window.addEventListener('resize', this.onWindowResize);
      this.raf = requestAnimationFrame(this.onAnimationFrame);
    }
  };

  Parallax.prototype.disable = function() {
    if (this.enabled) {
      this.enabled = false;
      if (this.orientationSupport) {
        window.removeEventListener('deviceorientation', this.onDeviceOrientation);
      } else {
        window.removeEventListener('mousemove', this.onMouseMove);
      }
      window.removeEventListener('resize', this.onWindowResize);
      cancelAnimationFrame(this.raf);
    }
  };

  Parallax.prototype.calibrate = function(x, y) {
    this.calibrateX = x === undefined ? this.calibrateX : x;
    this.calibrateY = y === undefined ? this.calibrateY : y;
  };

  Parallax.prototype.invert = function(x, y) {
    this.invertX = x === undefined ? this.invertX : x;
    this.invertY = y === undefined ? this.invertY : y;
  };

  Parallax.prototype.friction = function(x, y) {
    this.frictionX = x === undefined ? this.frictionX : x;
    this.frictionY = y === undefined ? this.frictionY : y;
  };

  Parallax.prototype.scalar = function(x, y) {
    this.scalarX = x === undefined ? this.scalarX : x;
    this.scalarY = y === undefined ? this.scalarY : y;
  };

  Parallax.prototype.limit = function(x, y) {
    this.limitX = x === undefined ? this.limitX : x;
    this.limitY = y === undefined ? this.limitY : y;
  };

  Parallax.prototype.origin = function(x, y) {
    this.originX = x === undefined ? this.originX : x;
    this.originY = y === undefined ? this.originY : y;
  };

  Parallax.prototype.clamp = function(value, min, max) {
    value = Math.max(value, min);
    value = Math.min(value, max);
    return value;
  };

  Parallax.prototype.css = function(element, property, value) {
    var jsProperty = this.propertyCache[property];
    if (!jsProperty) {
      for (var i = 0, l = this.vendors.length; i < l; i++) {
        if (this.vendors[i] !== null) {
          jsProperty = this.camelCase(this.vendors[i][1] + '-' + property);
        } else {
          jsProperty = property;
        }
        if (element.style[jsProperty] !== undefined) {
          this.propertyCache[property] = jsProperty;
          break;
        }
      }
    }
    element.style[jsProperty] = value;
  };

  Parallax.prototype.accelerate = function(element) {
    this.css(element, 'transform', 'translate3d(0,0,0)');
    this.css(element, 'transform-style', 'preserve-3d');
    this.css(element, 'backface-visibility', 'hidden');
  };

  Parallax.prototype.setPosition = function(element, x, y) {
    x += 'px';
    y += 'px';
    if (this.transform3DSupport) {
      this.css(element, 'transform', 'translate3d('+x+','+y+',0)');
    } else if (this.transform2DSupport) {
      this.css(element, 'transform', 'translate('+x+','+y+')');
    } else {
      element.style.left = x;
      element.style.top = y;
    }
  };

  Parallax.prototype.onOrientationTimer = function() {
    if (this.orientationSupport && this.orientationStatus === 0) {
      this.disable();
      this.orientationSupport = false;
      this.enable();
    }
  };

  Parallax.prototype.onCalibrationTimer = function() {
    this.calibrationFlag = true;
  };

  Parallax.prototype.onWindowResize = function() {
    this.updateDimensions();
  };

  Parallax.prototype.onAnimationFrame = function() {
    this.updateBounds();
    var dx = this.ix - this.cx;
    var dy = this.iy - this.cy;
    if ((Math.abs(dx) > this.calibrationThreshold) || (Math.abs(dy) > this.calibrationThreshold)) {
      this.queueCalibration(0);
    }
    if (this.portrait) {
      this.mx = this.calibrateX ? dy : this.iy;
      this.my = this.calibrateY ? dx : this.ix;
    } else {
      this.mx = this.calibrateX ? dx : this.ix;
      this.my = this.calibrateY ? dy : this.iy;
    }
    this.mx *= this.ew * (this.scalarX / 100);
    this.my *= this.eh * (this.scalarY / 100);
    if (!isNaN(parseFloat(this.limitX))) {
      this.mx = this.clamp(this.mx, -this.limitX, this.limitX);
    }
    if (!isNaN(parseFloat(this.limitY))) {
      this.my = this.clamp(this.my, -this.limitY, this.limitY);
    }
    this.vx += (this.mx - this.vx) * this.frictionX;
    this.vy += (this.my - this.vy) * this.frictionY;
    for (var i = 0, l = this.layers.length; i < l; i++) {
      var layer = this.layers[i];
      var depth = this.depths[i];
      var xOffset = this.vx * depth * (this.invertX ? -1 : 1);
      var yOffset = this.vy * depth * (this.invertY ? -1 : 1);
      this.setPosition(layer, xOffset, yOffset);
    }
    this.raf = requestAnimationFrame(this.onAnimationFrame);
  };

  Parallax.prototype.onDeviceOrientation = function(event) {

    // Validate environment and event properties.
    if (!this.desktop && event.beta !== null && event.gamma !== null) {

      // Set orientation status.
      this.orientationStatus = 1;

      // Extract Rotation
      var x = (event.beta  || 0) / MAGIC_NUMBER; //  -90 :: 90
      var y = (event.gamma || 0) / MAGIC_NUMBER; // -180 :: 180

      // Detect Orientation Change
      var portrait = this.wh > this.ww;
      if (this.portrait !== portrait) {
        this.portrait = portrait;
        this.calibrationFlag = true;
      }

      // Set Calibration
      if (this.calibrationFlag) {
        this.calibrationFlag = false;
        this.cx = x;
        this.cy = y;
      }

      // Set Input
      this.ix = x;
      this.iy = y;
    }
  };

  Parallax.prototype.onMouseMove = function(event) {

    // Cache mouse coordinates.
    var clientX = event.clientX;
    var clientY = event.clientY;

    // Calculate Mouse Input
    if (!this.orientationSupport && this.relativeInput) {

      // Clip mouse coordinates inside element bounds.
      if (this.clipRelativeInput) {
        clientX = Math.max(clientX, this.ex);
        clientX = Math.min(clientX, this.ex + this.ew);
        clientY = Math.max(clientY, this.ey);
        clientY = Math.min(clientY, this.ey + this.eh);
      }

      // Calculate input relative to the element.
      this.ix = (clientX - this.ex - this.ecx) / this.erx;
      this.iy = (clientY - this.ey - this.ecy) / this.ery;

    } else {

      // Calculate input relative to the window.
      this.ix = (clientX - this.wcx) / this.wrx;
      this.iy = (clientY - this.wcy) / this.wry;
    }
  };

  // Expose Parallax
  window[NAME] = Parallax;

})(window, document);

/**
 * Request Animation Frame Polyfill.
 * @author Tino Zijdel
 * @author Paul Irish
 * @see https://gist.github.com/paulirish/1579671
 */
;(function() {

  var lastTime = 0;
  var vendors = ['ms', 'moz', 'webkit', 'o'];

  for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
    window.requestAnimationFrame = window[vendors[x]+'RequestAnimationFrame'];
    window.cancelAnimationFrame = window[vendors[x]+'CancelAnimationFrame'] || window[vendors[x]+'CancelRequestAnimationFrame'];
  }

  if (!window.requestAnimationFrame) {
    window.requestAnimationFrame = function(callback, element) {
      var currTime = new Date().getTime();
      var timeToCall = Math.max(0, 16 - (currTime - lastTime));
      var id = window.setTimeout(function() { callback(currTime + timeToCall); },
        timeToCall);
      lastTime = currTime + timeToCall;
      return id;
    };
  }

  if (!window.cancelAnimationFrame) {
    window.cancelAnimationFrame = function(id) {
      clearTimeout(id);
    };
  }

}());
</script>
<script>
var scene2 = document.getElementById('scene2');
var parallax2 = new Parallax(scene2, {
  relativeInput: false,
  clipRelativeInput: false,
  calibrateX: false,
  calibrateY: true,
  invertX: false,
  invertY: true,
  limitX: false,
  limitY: false,
  scalarX: 5,
  scalarY: 5,
  frictionX: 0.8,
  frictionY: 0.8,
  originX: 0.5,
  originY: 0.5
});
</script>

<script>
$(".scene3").wrap("<ul id='scene3' class='scene'></ul>");
$(".layer31").wrap("<li class='layer' data-depth='1.00'></li>");
$(".layer32").wrap("<li class='layer' data-depth='0.20'></li>");
$(".layer33").wrap("<li class='layer' data-depth='0.40'></li>");
$(".layer34").wrap("<li class='layer' data-depth='0.60'></li>");
$(".layer35").wrap("<li class='layer' data-depth='0.80'></li>");
$(".layer36").wrap("<li class='layer' data-depth='1.00'></li>");
$(".layer37").wrap("<li class='layer' data-depth='1.00'></li>");
$(".layer38").wrap("<li class='layer' data-depth='0.20'></li>");
$(".layer39").wrap("<li class='layer' data-depth='0.40'></li>");
$(".layer310").wrap("<li class='layer' data-depth='0.60'></li>");
$(".layer311").wrap("<li class='layer' data-depth='0.80'></li>");
$(".layer312").wrap("<li class='layer' data-depth='1.00'></li>");
</script>
<script>
//============================================================
//
// The MIT License
//
// Copyright (C) 2014 Matthew Wagerfield - @wagerfield
//
// Permission is hereby granted, free of charge, to any
// person obtaining a copy of this software and associated
// documentation files (the "Software"), to deal in the
// Software without restriction, including without limitation
// the rights to use, copy, modify, merge, publish, distribute,
// sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do
// so, subject to the following conditions:
//
// The above copyright notice and this permission notice
// shall be included in all copies or substantial portions
// of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY
// OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
// LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
// EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
// AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
// OR OTHER DEALINGS IN THE SOFTWARE.
//
//============================================================

/**
 * Parallax.js
 * @author Matthew Wagerfield - @wagerfield
 * @description Creates a parallax effect between an array of layers,
 *              driving the motion from the gyroscope output of a smartdevice.
 *              If no gyroscope is available, the cursor position is used.
 */
;(function(window, document, undefined) {

  // Strict Mode
  'use strict';

  // Constants
  var NAME = 'Parallax';
  var MAGIC_NUMBER = 30;
  var DEFAULTS = {
    relativeInput: false,
    clipRelativeInput: false,
    calibrationThreshold: 100,
    calibrationDelay: 500,
    supportDelay: 500,
    calibrateX: false,
    calibrateY: true,
    invertX: true,
    invertY: true,
    limitX: false,
    limitY: false,
    scalarX: 10.0,
    scalarY: 10.0,
    frictionX: 0.1,
    frictionY: 0.1,
    originX: 0.5,
    originY: 0.5
  };

  function Parallax(element, options) {

    // DOM Context
    this.element = element;
    this.layers = element.getElementsByClassName('layer');

    // Data Extraction
    var data = {
      calibrateX: this.data(this.element, 'calibrate-x'),
      calibrateY: this.data(this.element, 'calibrate-y'),
      invertX: this.data(this.element, 'invert-x'),
      invertY: this.data(this.element, 'invert-y'),
      limitX: this.data(this.element, 'limit-x'),
      limitY: this.data(this.element, 'limit-y'),
      scalarX: this.data(this.element, 'scalar-x'),
      scalarY: this.data(this.element, 'scalar-y'),
      frictionX: this.data(this.element, 'friction-x'),
      frictionY: this.data(this.element, 'friction-y'),
      originX: this.data(this.element, 'origin-x'),
      originY: this.data(this.element, 'origin-y')
    };

    // Delete Null Data Values
    for (var key in data) {
      if (data[key] === null) delete data[key];
    }

    // Compose Settings Object
    this.extend(this, DEFAULTS, options, data);

    // States
    this.calibrationTimer = null;
    this.calibrationFlag = true;
    this.enabled = false;
    this.depths = [];
    this.raf = null;

    // Element Bounds
    this.bounds = null;
    this.ex = 0;
    this.ey = 0;
    this.ew = 0;
    this.eh = 0;

    // Element Center
    this.ecx = 0;
    this.ecy = 0;

    // Element Range
    this.erx = 0;
    this.ery = 0;

    // Calibration
    this.cx = 0;
    this.cy = 0;

    // Input
    this.ix = 0;
    this.iy = 0;

    // Motion
    this.mx = 0;
    this.my = 0;

    // Velocity
    this.vx = 0;
    this.vy = 0;

    // Callbacks
    this.onMouseMove = this.onMouseMove.bind(this);
    this.onDeviceOrientation = this.onDeviceOrientation.bind(this);
    this.onOrientationTimer = this.onOrientationTimer.bind(this);
    this.onCalibrationTimer = this.onCalibrationTimer.bind(this);
    this.onAnimationFrame = this.onAnimationFrame.bind(this);
    this.onWindowResize = this.onWindowResize.bind(this);

    // Initialise
    this.initialise();
  }

  Parallax.prototype.extend = function() {
    if (arguments.length > 1) {
      var master = arguments[0];
      for (var i = 1, l = arguments.length; i < l; i++) {
        var object = arguments[i];
        for (var key in object) {
          master[key] = object[key];
        }
      }
    }
  };

  Parallax.prototype.data = function(element, name) {
    return this.deserialize(element.getAttribute('data-'+name));
  };

  Parallax.prototype.deserialize = function(value) {
    if (value === 'true') {
      return true;
    } else if (value === 'false') {
      return false;
    } else if (value === 'null') {
      return null;
    } else if (!isNaN(parseFloat(value)) && isFinite(value)) {
      return parseFloat(value);
    } else {
      return value;
    }
  };

  Parallax.prototype.camelCase = function(value) {
    return value.replace(/-+(.)?/g, function(match, character){
      return character ? character.toUpperCase() : '';
    });
  };

  Parallax.prototype.transformSupport = function(value) {
    var element = document.createElement('div');
    var propertySupport = false;
    var propertyValue = null;
    var featureSupport = false;
    var cssProperty = null;
    var jsProperty = null;
    for (var i = 0, l = this.vendors.length; i < l; i++) {
      if (this.vendors[i] !== null) {
        cssProperty = this.vendors[i][0] + 'transform';
        jsProperty = this.vendors[i][1] + 'Transform';
      } else {
        cssProperty = 'transform';
        jsProperty = 'transform';
      }
      if (element.style[jsProperty] !== undefined) {
        propertySupport = true;
        break;
      }
    }
    switch(value) {
      case '2D':
        featureSupport = propertySupport;
        break;
      case '3D':
        if (propertySupport) {
          var body = document.body || document.createElement('body');
          var documentElement = document.documentElement;
          var documentOverflow = documentElement.style.overflow;
          if (!document.body) {
            documentElement.style.overflow = 'hidden';
            documentElement.appendChild(body);
            body.style.overflow = 'hidden';
            body.style.background = '';
          }
          body.appendChild(element);
          element.style[jsProperty] = 'translate3d(1px,1px,1px)';
          propertyValue = window.getComputedStyle(element).getPropertyValue(cssProperty);
          featureSupport = propertyValue !== undefined && propertyValue.length > 0 && propertyValue !== 'none';
          documentElement.style.overflow = documentOverflow;
          body.removeChild(element);
        }
        break;
    }
    return featureSupport;
  };

  Parallax.prototype.ww = null;
  Parallax.prototype.wh = null;
  Parallax.prototype.wcx = null;
  Parallax.prototype.wcy = null;
  Parallax.prototype.wrx = null;
  Parallax.prototype.wry = null;
  Parallax.prototype.portrait = null;
  Parallax.prototype.desktop = !navigator.userAgent.match(/(iPhone|iPod|iPad|Android|BlackBerry|BB10|mobi|tablet|opera mini|nexus 7)/i);
  Parallax.prototype.vendors = [null,['-webkit-','webkit'],['-moz-','Moz'],['-o-','O'],['-ms-','ms']];
  Parallax.prototype.motionSupport = !!window.DeviceMotionEvent;
  Parallax.prototype.orientationSupport = !!window.DeviceOrientationEvent;
  Parallax.prototype.orientationStatus = 0;
  Parallax.prototype.propertyCache = {};

  Parallax.prototype.initialise = function() {

    if (Parallax.prototype.transform2DSupport === undefined) {
      Parallax.prototype.transform2DSupport = Parallax.prototype.transformSupport('2D');
      Parallax.prototype.transform3DSupport = Parallax.prototype.transformSupport('3D');
    }

    // Configure Context Styles
    if (this.transform3DSupport) this.accelerate(this.element);
    var style = window.getComputedStyle(this.element);
    if (style.getPropertyValue('position') === 'static') {
      this.element.style.position = 'relative';
    }

    // Setup
    this.updateLayers();
    this.updateDimensions();
    this.enable();
    this.queueCalibration(this.calibrationDelay);
  };

  Parallax.prototype.updateLayers = function() {

    // Cache Layer Elements
    this.layers = this.element.getElementsByClassName('layer');
    this.depths = [];

    // Configure Layer Styles
    for (var i = 0, l = this.layers.length; i < l; i++) {
      var layer = this.layers[i];
      if (this.transform3DSupport) this.accelerate(layer);

      // Cache Layer Depth
      this.depths.push(this.data(layer, 'depth') || 0);
    }
  };

  Parallax.prototype.updateDimensions = function() {
    this.ww = window.innerWidth;
    this.wh = window.innerHeight;
    this.wcx = this.ww * this.originX;
    this.wcy = this.wh * this.originY;
    this.wrx = Math.max(this.wcx, this.ww - this.wcx);
    this.wry = Math.max(this.wcy, this.wh - this.wcy);
  };

  Parallax.prototype.updateBounds = function() {
    this.bounds = this.element.getBoundingClientRect();
    this.ex = this.bounds.left;
    this.ey = this.bounds.top;
    this.ew = this.bounds.width;
    this.eh = this.bounds.height;
    this.ecx = this.ew * this.originX;
    this.ecy = this.eh * this.originY;
    this.erx = Math.max(this.ecx, this.ew - this.ecx);
    this.ery = Math.max(this.ecy, this.eh - this.ecy);
  };

  Parallax.prototype.queueCalibration = function(delay) {
    clearTimeout(this.calibrationTimer);
    this.calibrationTimer = setTimeout(this.onCalibrationTimer, delay);
  };

  Parallax.prototype.enable = function() {
    if (!this.enabled) {
      this.enabled = true;
      if (this.orientationSupport) {
        this.portrait = null;
        window.addEventListener('deviceorientation', this.onDeviceOrientation);
        setTimeout(this.onOrientationTimer, this.supportDelay);
      } else {
        this.cx = 0;
        this.cy = 0;
        this.portrait = false;
        window.addEventListener('mousemove', this.onMouseMove);
      }
      window.addEventListener('resize', this.onWindowResize);
      this.raf = requestAnimationFrame(this.onAnimationFrame);
    }
  };

  Parallax.prototype.disable = function() {
    if (this.enabled) {
      this.enabled = false;
      if (this.orientationSupport) {
        window.removeEventListener('deviceorientation', this.onDeviceOrientation);
      } else {
        window.removeEventListener('mousemove', this.onMouseMove);
      }
      window.removeEventListener('resize', this.onWindowResize);
      cancelAnimationFrame(this.raf);
    }
  };

  Parallax.prototype.calibrate = function(x, y) {
    this.calibrateX = x === undefined ? this.calibrateX : x;
    this.calibrateY = y === undefined ? this.calibrateY : y;
  };

  Parallax.prototype.invert = function(x, y) {
    this.invertX = x === undefined ? this.invertX : x;
    this.invertY = y === undefined ? this.invertY : y;
  };

  Parallax.prototype.friction = function(x, y) {
    this.frictionX = x === undefined ? this.frictionX : x;
    this.frictionY = y === undefined ? this.frictionY : y;
  };

  Parallax.prototype.scalar = function(x, y) {
    this.scalarX = x === undefined ? this.scalarX : x;
    this.scalarY = y === undefined ? this.scalarY : y;
  };

  Parallax.prototype.limit = function(x, y) {
    this.limitX = x === undefined ? this.limitX : x;
    this.limitY = y === undefined ? this.limitY : y;
  };

  Parallax.prototype.origin = function(x, y) {
    this.originX = x === undefined ? this.originX : x;
    this.originY = y === undefined ? this.originY : y;
  };

  Parallax.prototype.clamp = function(value, min, max) {
    value = Math.max(value, min);
    value = Math.min(value, max);
    return value;
  };

  Parallax.prototype.css = function(element, property, value) {
    var jsProperty = this.propertyCache[property];
    if (!jsProperty) {
      for (var i = 0, l = this.vendors.length; i < l; i++) {
        if (this.vendors[i] !== null) {
          jsProperty = this.camelCase(this.vendors[i][1] + '-' + property);
        } else {
          jsProperty = property;
        }
        if (element.style[jsProperty] !== undefined) {
          this.propertyCache[property] = jsProperty;
          break;
        }
      }
    }
    element.style[jsProperty] = value;
  };

  Parallax.prototype.accelerate = function(element) {
    this.css(element, 'transform', 'translate3d(0,0,0)');
    this.css(element, 'transform-style', 'preserve-3d');
    this.css(element, 'backface-visibility', 'hidden');
  };

  Parallax.prototype.setPosition = function(element, x, y) {
    x += 'px';
    y += 'px';
    if (this.transform3DSupport) {
      this.css(element, 'transform', 'translate3d('+x+','+y+',0)');
    } else if (this.transform2DSupport) {
      this.css(element, 'transform', 'translate('+x+','+y+')');
    } else {
      element.style.left = x;
      element.style.top = y;
    }
  };

  Parallax.prototype.onOrientationTimer = function() {
    if (this.orientationSupport && this.orientationStatus === 0) {
      this.disable();
      this.orientationSupport = false;
      this.enable();
    }
  };

  Parallax.prototype.onCalibrationTimer = function() {
    this.calibrationFlag = true;
  };

  Parallax.prototype.onWindowResize = function() {
    this.updateDimensions();
  };

  Parallax.prototype.onAnimationFrame = function() {
    this.updateBounds();
    var dx = this.ix - this.cx;
    var dy = this.iy - this.cy;
    if ((Math.abs(dx) > this.calibrationThreshold) || (Math.abs(dy) > this.calibrationThreshold)) {
      this.queueCalibration(0);
    }
    if (this.portrait) {
      this.mx = this.calibrateX ? dy : this.iy;
      this.my = this.calibrateY ? dx : this.ix;
    } else {
      this.mx = this.calibrateX ? dx : this.ix;
      this.my = this.calibrateY ? dy : this.iy;
    }
    this.mx *= this.ew * (this.scalarX / 100);
    this.my *= this.eh * (this.scalarY / 100);
    if (!isNaN(parseFloat(this.limitX))) {
      this.mx = this.clamp(this.mx, -this.limitX, this.limitX);
    }
    if (!isNaN(parseFloat(this.limitY))) {
      this.my = this.clamp(this.my, -this.limitY, this.limitY);
    }
    this.vx += (this.mx - this.vx) * this.frictionX;
    this.vy += (this.my - this.vy) * this.frictionY;
    for (var i = 0, l = this.layers.length; i < l; i++) {
      var layer = this.layers[i];
      var depth = this.depths[i];
      var xOffset = this.vx * depth * (this.invertX ? -1 : 1);
      var yOffset = this.vy * depth * (this.invertY ? -1 : 1);
      this.setPosition(layer, xOffset, yOffset);
    }
    this.raf = requestAnimationFrame(this.onAnimationFrame);
  };

  Parallax.prototype.onDeviceOrientation = function(event) {

    // Validate environment and event properties.
    if (!this.desktop && event.beta !== null && event.gamma !== null) {

      // Set orientation status.
      this.orientationStatus = 1;

      // Extract Rotation
      var x = (event.beta  || 0) / MAGIC_NUMBER; //  -90 :: 90
      var y = (event.gamma || 0) / MAGIC_NUMBER; // -180 :: 180

      // Detect Orientation Change
      var portrait = this.wh > this.ww;
      if (this.portrait !== portrait) {
        this.portrait = portrait;
        this.calibrationFlag = true;
      }

      // Set Calibration
      if (this.calibrationFlag) {
        this.calibrationFlag = false;
        this.cx = x;
        this.cy = y;
      }

      // Set Input
      this.ix = x;
      this.iy = y;
    }
  };

  Parallax.prototype.onMouseMove = function(event) {

    // Cache mouse coordinates.
    var clientX = event.clientX;
    var clientY = event.clientY;

    // Calculate Mouse Input
    if (!this.orientationSupport && this.relativeInput) {

      // Clip mouse coordinates inside element bounds.
      if (this.clipRelativeInput) {
        clientX = Math.max(clientX, this.ex);
        clientX = Math.min(clientX, this.ex + this.ew);
        clientY = Math.max(clientY, this.ey);
        clientY = Math.min(clientY, this.ey + this.eh);
      }

      // Calculate input relative to the element.
      this.ix = (clientX - this.ex - this.ecx) / this.erx;
      this.iy = (clientY - this.ey - this.ecy) / this.ery;

    } else {

      // Calculate input relative to the window.
      this.ix = (clientX - this.wcx) / this.wrx;
      this.iy = (clientY - this.wcy) / this.wry;
    }
  };

  // Expose Parallax
  window[NAME] = Parallax;

})(window, document);

/**
 * Request Animation Frame Polyfill.
 * @author Tino Zijdel
 * @author Paul Irish
 * @see https://gist.github.com/paulirish/1579671
 */
;(function() {

  var lastTime = 0;
  var vendors = ['ms', 'moz', 'webkit', 'o'];

  for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
    window.requestAnimationFrame = window[vendors[x]+'RequestAnimationFrame'];
    window.cancelAnimationFrame = window[vendors[x]+'CancelAnimationFrame'] || window[vendors[x]+'CancelRequestAnimationFrame'];
  }

  if (!window.requestAnimationFrame) {
    window.requestAnimationFrame = function(callback, element) {
      var currTime = new Date().getTime();
      var timeToCall = Math.max(0, 16 - (currTime - lastTime));
      var id = window.setTimeout(function() { callback(currTime + timeToCall); },
        timeToCall);
      lastTime = currTime + timeToCall;
      return id;
    };
  }

  if (!window.cancelAnimationFrame) {
    window.cancelAnimationFrame = function(id) {
      clearTimeout(id);
    };
  }

}());
</script>
<script>
var scene3 = document.getElementById('scene3');
var parallax3 = new Parallax(scene3, {
  relativeInput: false,
  clipRelativeInput: false,
  calibrateX: false,
  calibrateY: true,
  invertX: false,
  invertY: true,
  limitX: false,
  limitY: false,
  scalarX: 5,
  scalarY: 5,
  frictionX: 0.8,
  frictionY: 0.8,
  originX: 0.5,
  originY: 0.5
});
</script>

<script>
$(".scene4").wrap("<ul id='scene4' class='scene'></ul>");
$(".layer41").wrap("<li class='layer' data-depth='1.00'></li>");
$(".layer42").wrap("<li class='layer' data-depth='0.20'></li>");
$(".layer43").wrap("<li class='layer' data-depth='0.40'></li>");
$(".layer44").wrap("<li class='layer' data-depth='0.60'></li>");
$(".layer45").wrap("<li class='layer' data-depth='0.80'></li>");
$(".layer46").wrap("<li class='layer' data-depth='1.00'></li>");
$(".layer47").wrap("<li class='layer' data-depth='1.00'></li>");
$(".layer48").wrap("<li class='layer' data-depth='0.20'></li>");
$(".layer49").wrap("<li class='layer' data-depth='0.40'></li>");
$(".layer410").wrap("<li class='layer' data-depth='0.60'></li>");
$(".layer411").wrap("<li class='layer' data-depth='0.80'></li>");
$(".layer412").wrap("<li class='layer' data-depth='1.00'></li>");
</script>
<script>
//============================================================
//
// The MIT License
//
// Copyright (C) 2014 Matthew Wagerfield - @wagerfield
//
// Permission is hereby granted, free of charge, to any
// person obtaining a copy of this software and associated
// documentation files (the "Software"), to deal in the
// Software without restriction, including without limitation
// the rights to use, copy, modify, merge, publish, distribute,
// sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do
// so, subject to the following conditions:
//
// The above copyright notice and this permission notice
// shall be included in all copies or substantial portions
// of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY
// OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
// LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
// EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
// AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
// OR OTHER DEALINGS IN THE SOFTWARE.
//
//============================================================

/**
 * Parallax.js
 * @author Matthew Wagerfield - @wagerfield
 * @description Creates a parallax effect between an array of layers,
 *              driving the motion from the gyroscope output of a smartdevice.
 *              If no gyroscope is available, the cursor position is used.
 */
;(function(window, document, undefined) {

  // Strict Mode
  'use strict';

  // Constants
  var NAME = 'Parallax';
  var MAGIC_NUMBER = 30;
  var DEFAULTS = {
    relativeInput: false,
    clipRelativeInput: false,
    calibrationThreshold: 100,
    calibrationDelay: 500,
    supportDelay: 500,
    calibrateX: false,
    calibrateY: true,
    invertX: true,
    invertY: true,
    limitX: false,
    limitY: false,
    scalarX: 10.0,
    scalarY: 10.0,
    frictionX: 0.1,
    frictionY: 0.1,
    originX: 0.5,
    originY: 0.5
  };

  function Parallax(element, options) {

    // DOM Context
    this.element = element;
    this.layers = element.getElementsByClassName('layer');

    // Data Extraction
    var data = {
      calibrateX: this.data(this.element, 'calibrate-x'),
      calibrateY: this.data(this.element, 'calibrate-y'),
      invertX: this.data(this.element, 'invert-x'),
      invertY: this.data(this.element, 'invert-y'),
      limitX: this.data(this.element, 'limit-x'),
      limitY: this.data(this.element, 'limit-y'),
      scalarX: this.data(this.element, 'scalar-x'),
      scalarY: this.data(this.element, 'scalar-y'),
      frictionX: this.data(this.element, 'friction-x'),
      frictionY: this.data(this.element, 'friction-y'),
      originX: this.data(this.element, 'origin-x'),
      originY: this.data(this.element, 'origin-y')
    };

    // Delete Null Data Values
    for (var key in data) {
      if (data[key] === null) delete data[key];
    }

    // Compose Settings Object
    this.extend(this, DEFAULTS, options, data);

    // States
    this.calibrationTimer = null;
    this.calibrationFlag = true;
    this.enabled = false;
    this.depths = [];
    this.raf = null;

    // Element Bounds
    this.bounds = null;
    this.ex = 0;
    this.ey = 0;
    this.ew = 0;
    this.eh = 0;

    // Element Center
    this.ecx = 0;
    this.ecy = 0;

    // Element Range
    this.erx = 0;
    this.ery = 0;

    // Calibration
    this.cx = 0;
    this.cy = 0;

    // Input
    this.ix = 0;
    this.iy = 0;

    // Motion
    this.mx = 0;
    this.my = 0;

    // Velocity
    this.vx = 0;
    this.vy = 0;

    // Callbacks
    this.onMouseMove = this.onMouseMove.bind(this);
    this.onDeviceOrientation = this.onDeviceOrientation.bind(this);
    this.onOrientationTimer = this.onOrientationTimer.bind(this);
    this.onCalibrationTimer = this.onCalibrationTimer.bind(this);
    this.onAnimationFrame = this.onAnimationFrame.bind(this);
    this.onWindowResize = this.onWindowResize.bind(this);

    // Initialise
    this.initialise();
  }

  Parallax.prototype.extend = function() {
    if (arguments.length > 1) {
      var master = arguments[0];
      for (var i = 1, l = arguments.length; i < l; i++) {
        var object = arguments[i];
        for (var key in object) {
          master[key] = object[key];
        }
      }
    }
  };

  Parallax.prototype.data = function(element, name) {
    return this.deserialize(element.getAttribute('data-'+name));
  };

  Parallax.prototype.deserialize = function(value) {
    if (value === 'true') {
      return true;
    } else if (value === 'false') {
      return false;
    } else if (value === 'null') {
      return null;
    } else if (!isNaN(parseFloat(value)) && isFinite(value)) {
      return parseFloat(value);
    } else {
      return value;
    }
  };

  Parallax.prototype.camelCase = function(value) {
    return value.replace(/-+(.)?/g, function(match, character){
      return character ? character.toUpperCase() : '';
    });
  };

  Parallax.prototype.transformSupport = function(value) {
    var element = document.createElement('div');
    var propertySupport = false;
    var propertyValue = null;
    var featureSupport = false;
    var cssProperty = null;
    var jsProperty = null;
    for (var i = 0, l = this.vendors.length; i < l; i++) {
      if (this.vendors[i] !== null) {
        cssProperty = this.vendors[i][0] + 'transform';
        jsProperty = this.vendors[i][1] + 'Transform';
      } else {
        cssProperty = 'transform';
        jsProperty = 'transform';
      }
      if (element.style[jsProperty] !== undefined) {
        propertySupport = true;
        break;
      }
    }
    switch(value) {
      case '2D':
        featureSupport = propertySupport;
        break;
      case '3D':
        if (propertySupport) {
          var body = document.body || document.createElement('body');
          var documentElement = document.documentElement;
          var documentOverflow = documentElement.style.overflow;
          if (!document.body) {
            documentElement.style.overflow = 'hidden';
            documentElement.appendChild(body);
            body.style.overflow = 'hidden';
            body.style.background = '';
          }
          body.appendChild(element);
          element.style[jsProperty] = 'translate3d(1px,1px,1px)';
          propertyValue = window.getComputedStyle(element).getPropertyValue(cssProperty);
          featureSupport = propertyValue !== undefined && propertyValue.length > 0 && propertyValue !== 'none';
          documentElement.style.overflow = documentOverflow;
          body.removeChild(element);
        }
        break;
    }
    return featureSupport;
  };

  Parallax.prototype.ww = null;
  Parallax.prototype.wh = null;
  Parallax.prototype.wcx = null;
  Parallax.prototype.wcy = null;
  Parallax.prototype.wrx = null;
  Parallax.prototype.wry = null;
  Parallax.prototype.portrait = null;
  Parallax.prototype.desktop = !navigator.userAgent.match(/(iPhone|iPod|iPad|Android|BlackBerry|BB10|mobi|tablet|opera mini|nexus 7)/i);
  Parallax.prototype.vendors = [null,['-webkit-','webkit'],['-moz-','Moz'],['-o-','O'],['-ms-','ms']];
  Parallax.prototype.motionSupport = !!window.DeviceMotionEvent;
  Parallax.prototype.orientationSupport = !!window.DeviceOrientationEvent;
  Parallax.prototype.orientationStatus = 0;
  Parallax.prototype.propertyCache = {};

  Parallax.prototype.initialise = function() {

    if (Parallax.prototype.transform2DSupport === undefined) {
      Parallax.prototype.transform2DSupport = Parallax.prototype.transformSupport('2D');
      Parallax.prototype.transform3DSupport = Parallax.prototype.transformSupport('3D');
    }

    // Configure Context Styles
    if (this.transform3DSupport) this.accelerate(this.element);
    var style = window.getComputedStyle(this.element);
    if (style.getPropertyValue('position') === 'static') {
      this.element.style.position = 'relative';
    }

    // Setup
    this.updateLayers();
    this.updateDimensions();
    this.enable();
    this.queueCalibration(this.calibrationDelay);
  };

  Parallax.prototype.updateLayers = function() {

    // Cache Layer Elements
    this.layers = this.element.getElementsByClassName('layer');
    this.depths = [];

    // Configure Layer Styles
    for (var i = 0, l = this.layers.length; i < l; i++) {
      var layer = this.layers[i];
      if (this.transform3DSupport) this.accelerate(layer);

      // Cache Layer Depth
      this.depths.push(this.data(layer, 'depth') || 0);
    }
  };

  Parallax.prototype.updateDimensions = function() {
    this.ww = window.innerWidth;
    this.wh = window.innerHeight;
    this.wcx = this.ww * this.originX;
    this.wcy = this.wh * this.originY;
    this.wrx = Math.max(this.wcx, this.ww - this.wcx);
    this.wry = Math.max(this.wcy, this.wh - this.wcy);
  };

  Parallax.prototype.updateBounds = function() {
    this.bounds = this.element.getBoundingClientRect();
    this.ex = this.bounds.left;
    this.ey = this.bounds.top;
    this.ew = this.bounds.width;
    this.eh = this.bounds.height;
    this.ecx = this.ew * this.originX;
    this.ecy = this.eh * this.originY;
    this.erx = Math.max(this.ecx, this.ew - this.ecx);
    this.ery = Math.max(this.ecy, this.eh - this.ecy);
  };

  Parallax.prototype.queueCalibration = function(delay) {
    clearTimeout(this.calibrationTimer);
    this.calibrationTimer = setTimeout(this.onCalibrationTimer, delay);
  };

  Parallax.prototype.enable = function() {
    if (!this.enabled) {
      this.enabled = true;
      if (this.orientationSupport) {
        this.portrait = null;
        window.addEventListener('deviceorientation', this.onDeviceOrientation);
        setTimeout(this.onOrientationTimer, this.supportDelay);
      } else {
        this.cx = 0;
        this.cy = 0;
        this.portrait = false;
        window.addEventListener('mousemove', this.onMouseMove);
      }
      window.addEventListener('resize', this.onWindowResize);
      this.raf = requestAnimationFrame(this.onAnimationFrame);
    }
  };

  Parallax.prototype.disable = function() {
    if (this.enabled) {
      this.enabled = false;
      if (this.orientationSupport) {
        window.removeEventListener('deviceorientation', this.onDeviceOrientation);
      } else {
        window.removeEventListener('mousemove', this.onMouseMove);
      }
      window.removeEventListener('resize', this.onWindowResize);
      cancelAnimationFrame(this.raf);
    }
  };

  Parallax.prototype.calibrate = function(x, y) {
    this.calibrateX = x === undefined ? this.calibrateX : x;
    this.calibrateY = y === undefined ? this.calibrateY : y;
  };

  Parallax.prototype.invert = function(x, y) {
    this.invertX = x === undefined ? this.invertX : x;
    this.invertY = y === undefined ? this.invertY : y;
  };

  Parallax.prototype.friction = function(x, y) {
    this.frictionX = x === undefined ? this.frictionX : x;
    this.frictionY = y === undefined ? this.frictionY : y;
  };

  Parallax.prototype.scalar = function(x, y) {
    this.scalarX = x === undefined ? this.scalarX : x;
    this.scalarY = y === undefined ? this.scalarY : y;
  };

  Parallax.prototype.limit = function(x, y) {
    this.limitX = x === undefined ? this.limitX : x;
    this.limitY = y === undefined ? this.limitY : y;
  };

  Parallax.prototype.origin = function(x, y) {
    this.originX = x === undefined ? this.originX : x;
    this.originY = y === undefined ? this.originY : y;
  };

  Parallax.prototype.clamp = function(value, min, max) {
    value = Math.max(value, min);
    value = Math.min(value, max);
    return value;
  };

  Parallax.prototype.css = function(element, property, value) {
    var jsProperty = this.propertyCache[property];
    if (!jsProperty) {
      for (var i = 0, l = this.vendors.length; i < l; i++) {
        if (this.vendors[i] !== null) {
          jsProperty = this.camelCase(this.vendors[i][1] + '-' + property);
        } else {
          jsProperty = property;
        }
        if (element.style[jsProperty] !== undefined) {
          this.propertyCache[property] = jsProperty;
          break;
        }
      }
    }
    element.style[jsProperty] = value;
  };

  Parallax.prototype.accelerate = function(element) {
    this.css(element, 'transform', 'translate3d(0,0,0)');
    this.css(element, 'transform-style', 'preserve-3d');
    this.css(element, 'backface-visibility', 'hidden');
  };

  Parallax.prototype.setPosition = function(element, x, y) {
    x += 'px';
    y += 'px';
    if (this.transform3DSupport) {
      this.css(element, 'transform', 'translate3d('+x+','+y+',0)');
    } else if (this.transform2DSupport) {
      this.css(element, 'transform', 'translate('+x+','+y+')');
    } else {
      element.style.left = x;
      element.style.top = y;
    }
  };

  Parallax.prototype.onOrientationTimer = function() {
    if (this.orientationSupport && this.orientationStatus === 0) {
      this.disable();
      this.orientationSupport = false;
      this.enable();
    }
  };

  Parallax.prototype.onCalibrationTimer = function() {
    this.calibrationFlag = true;
  };

  Parallax.prototype.onWindowResize = function() {
    this.updateDimensions();
  };

  Parallax.prototype.onAnimationFrame = function() {
    this.updateBounds();
    var dx = this.ix - this.cx;
    var dy = this.iy - this.cy;
    if ((Math.abs(dx) > this.calibrationThreshold) || (Math.abs(dy) > this.calibrationThreshold)) {
      this.queueCalibration(0);
    }
    if (this.portrait) {
      this.mx = this.calibrateX ? dy : this.iy;
      this.my = this.calibrateY ? dx : this.ix;
    } else {
      this.mx = this.calibrateX ? dx : this.ix;
      this.my = this.calibrateY ? dy : this.iy;
    }
    this.mx *= this.ew * (this.scalarX / 100);
    this.my *= this.eh * (this.scalarY / 100);
    if (!isNaN(parseFloat(this.limitX))) {
      this.mx = this.clamp(this.mx, -this.limitX, this.limitX);
    }
    if (!isNaN(parseFloat(this.limitY))) {
      this.my = this.clamp(this.my, -this.limitY, this.limitY);
    }
    this.vx += (this.mx - this.vx) * this.frictionX;
    this.vy += (this.my - this.vy) * this.frictionY;
    for (var i = 0, l = this.layers.length; i < l; i++) {
      var layer = this.layers[i];
      var depth = this.depths[i];
      var xOffset = this.vx * depth * (this.invertX ? -1 : 1);
      var yOffset = this.vy * depth * (this.invertY ? -1 : 1);
      this.setPosition(layer, xOffset, yOffset);
    }
    this.raf = requestAnimationFrame(this.onAnimationFrame);
  };

  Parallax.prototype.onDeviceOrientation = function(event) {

    // Validate environment and event properties.
    if (!this.desktop && event.beta !== null && event.gamma !== null) {

      // Set orientation status.
      this.orientationStatus = 1;

      // Extract Rotation
      var x = (event.beta  || 0) / MAGIC_NUMBER; //  -90 :: 90
      var y = (event.gamma || 0) / MAGIC_NUMBER; // -180 :: 180

      // Detect Orientation Change
      var portrait = this.wh > this.ww;
      if (this.portrait !== portrait) {
        this.portrait = portrait;
        this.calibrationFlag = true;
      }

      // Set Calibration
      if (this.calibrationFlag) {
        this.calibrationFlag = false;
        this.cx = x;
        this.cy = y;
      }

      // Set Input
      this.ix = x;
      this.iy = y;
    }
  };

  Parallax.prototype.onMouseMove = function(event) {

    // Cache mouse coordinates.
    var clientX = event.clientX;
    var clientY = event.clientY;

    // Calculate Mouse Input
    if (!this.orientationSupport && this.relativeInput) {

      // Clip mouse coordinates inside element bounds.
      if (this.clipRelativeInput) {
        clientX = Math.max(clientX, this.ex);
        clientX = Math.min(clientX, this.ex + this.ew);
        clientY = Math.max(clientY, this.ey);
        clientY = Math.min(clientY, this.ey + this.eh);
      }

      // Calculate input relative to the element.
      this.ix = (clientX - this.ex - this.ecx) / this.erx;
      this.iy = (clientY - this.ey - this.ecy) / this.ery;

    } else {

      // Calculate input relative to the window.
      this.ix = (clientX - this.wcx) / this.wrx;
      this.iy = (clientY - this.wcy) / this.wry;
    }
  };

  // Expose Parallax
  window[NAME] = Parallax;

})(window, document);

/**
 * Request Animation Frame Polyfill.
 * @author Tino Zijdel
 * @author Paul Irish
 * @see https://gist.github.com/paulirish/1579671
 */
;(function() {

  var lastTime = 0;
  var vendors = ['ms', 'moz', 'webkit', 'o'];

  for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
    window.requestAnimationFrame = window[vendors[x]+'RequestAnimationFrame'];
    window.cancelAnimationFrame = window[vendors[x]+'CancelAnimationFrame'] || window[vendors[x]+'CancelRequestAnimationFrame'];
  }

  if (!window.requestAnimationFrame) {
    window.requestAnimationFrame = function(callback, element) {
      var currTime = new Date().getTime();
      var timeToCall = Math.max(0, 16 - (currTime - lastTime));
      var id = window.setTimeout(function() { callback(currTime + timeToCall); },
        timeToCall);
      lastTime = currTime + timeToCall;
      return id;
    };
  }

  if (!window.cancelAnimationFrame) {
    window.cancelAnimationFrame = function(id) {
      clearTimeout(id);
    };
  }

}());
</script>
<script>
var scene4 = document.getElementById('scene4');
var parallax4 = new Parallax(scene4, {
  relativeInput: false,
  clipRelativeInput: false,
  calibrateX: false,
  calibrateY: true,
  invertX: false,
  invertY: true,
  limitX: false,
  limitY: false,
  scalarX: 5,
  scalarY: 5,
  frictionX: 0.8,
  frictionY: 0.8,
  originX: 0.5,
  originY: 0.5
});
</script>

<script>
$(".scene5").wrap("<ul id='scene5' class='scene'></ul>");
$(".layer51").wrap("<li class='layer' data-depth='1.00'></li>");
$(".layer52").wrap("<li class='layer' data-depth='0.20'></li>");
$(".layer53").wrap("<li class='layer' data-depth='0.40'></li>");
$(".layer54").wrap("<li class='layer' data-depth='0.60'></li>");
$(".layer55").wrap("<li class='layer' data-depth='0.80'></li>");
$(".layer56").wrap("<li class='layer' data-depth='1.00'></li>");
$(".layer57").wrap("<li class='layer' data-depth='1.00'></li>");
$(".layer58").wrap("<li class='layer' data-depth='0.20'></li>");
$(".layer59").wrap("<li class='layer' data-depth='0.40'></li>");
$(".layer510").wrap("<li class='layer' data-depth='0.60'></li>");
$(".layer511").wrap("<li class='layer' data-depth='0.80'></li>");
$(".layer512").wrap("<li class='layer' data-depth='1.00'></li>");
</script>
<script>
//============================================================
//
// The MIT License
//
// Copyright (C) 2014 Matthew Wagerfield - @wagerfield
//
// Permission is hereby granted, free of charge, to any
// person obtaining a copy of this software and associated
// documentation files (the "Software"), to deal in the
// Software without restriction, including without limitation
// the rights to use, copy, modify, merge, publish, distribute,
// sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do
// so, subject to the following conditions:
//
// The above copyright notice and this permission notice
// shall be included in all copies or substantial portions
// of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY
// OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
// LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
// EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
// AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
// OR OTHER DEALINGS IN THE SOFTWARE.
//
//============================================================

/**
 * Parallax.js
 * @author Matthew Wagerfield - @wagerfield
 * @description Creates a parallax effect between an array of layers,
 *              driving the motion from the gyroscope output of a smartdevice.
 *              If no gyroscope is available, the cursor position is used.
 */
;(function(window, document, undefined) {

  // Strict Mode
  'use strict';

  // Constants
  var NAME = 'Parallax';
  var MAGIC_NUMBER = 30;
  var DEFAULTS = {
    relativeInput: false,
    clipRelativeInput: false,
    calibrationThreshold: 100,
    calibrationDelay: 500,
    supportDelay: 500,
    calibrateX: false,
    calibrateY: true,
    invertX: true,
    invertY: true,
    limitX: false,
    limitY: false,
    scalarX: 10.0,
    scalarY: 10.0,
    frictionX: 0.1,
    frictionY: 0.1,
    originX: 0.5,
    originY: 0.5
  };

  function Parallax(element, options) {

    // DOM Context
    this.element = element;
    this.layers = element.getElementsByClassName('layer');

    // Data Extraction
    var data = {
      calibrateX: this.data(this.element, 'calibrate-x'),
      calibrateY: this.data(this.element, 'calibrate-y'),
      invertX: this.data(this.element, 'invert-x'),
      invertY: this.data(this.element, 'invert-y'),
      limitX: this.data(this.element, 'limit-x'),
      limitY: this.data(this.element, 'limit-y'),
      scalarX: this.data(this.element, 'scalar-x'),
      scalarY: this.data(this.element, 'scalar-y'),
      frictionX: this.data(this.element, 'friction-x'),
      frictionY: this.data(this.element, 'friction-y'),
      originX: this.data(this.element, 'origin-x'),
      originY: this.data(this.element, 'origin-y')
    };

    // Delete Null Data Values
    for (var key in data) {
      if (data[key] === null) delete data[key];
    }

    // Compose Settings Object
    this.extend(this, DEFAULTS, options, data);

    // States
    this.calibrationTimer = null;
    this.calibrationFlag = true;
    this.enabled = false;
    this.depths = [];
    this.raf = null;

    // Element Bounds
    this.bounds = null;
    this.ex = 0;
    this.ey = 0;
    this.ew = 0;
    this.eh = 0;

    // Element Center
    this.ecx = 0;
    this.ecy = 0;

    // Element Range
    this.erx = 0;
    this.ery = 0;

    // Calibration
    this.cx = 0;
    this.cy = 0;

    // Input
    this.ix = 0;
    this.iy = 0;

    // Motion
    this.mx = 0;
    this.my = 0;

    // Velocity
    this.vx = 0;
    this.vy = 0;

    // Callbacks
    this.onMouseMove = this.onMouseMove.bind(this);
    this.onDeviceOrientation = this.onDeviceOrientation.bind(this);
    this.onOrientationTimer = this.onOrientationTimer.bind(this);
    this.onCalibrationTimer = this.onCalibrationTimer.bind(this);
    this.onAnimationFrame = this.onAnimationFrame.bind(this);
    this.onWindowResize = this.onWindowResize.bind(this);

    // Initialise
    this.initialise();
  }

  Parallax.prototype.extend = function() {
    if (arguments.length > 1) {
      var master = arguments[0];
      for (var i = 1, l = arguments.length; i < l; i++) {
        var object = arguments[i];
        for (var key in object) {
          master[key] = object[key];
        }
      }
    }
  };

  Parallax.prototype.data = function(element, name) {
    return this.deserialize(element.getAttribute('data-'+name));
  };

  Parallax.prototype.deserialize = function(value) {
    if (value === 'true') {
      return true;
    } else if (value === 'false') {
      return false;
    } else if (value === 'null') {
      return null;
    } else if (!isNaN(parseFloat(value)) && isFinite(value)) {
      return parseFloat(value);
    } else {
      return value;
    }
  };

  Parallax.prototype.camelCase = function(value) {
    return value.replace(/-+(.)?/g, function(match, character){
      return character ? character.toUpperCase() : '';
    });
  };

  Parallax.prototype.transformSupport = function(value) {
    var element = document.createElement('div');
    var propertySupport = false;
    var propertyValue = null;
    var featureSupport = false;
    var cssProperty = null;
    var jsProperty = null;
    for (var i = 0, l = this.vendors.length; i < l; i++) {
      if (this.vendors[i] !== null) {
        cssProperty = this.vendors[i][0] + 'transform';
        jsProperty = this.vendors[i][1] + 'Transform';
      } else {
        cssProperty = 'transform';
        jsProperty = 'transform';
      }
      if (element.style[jsProperty] !== undefined) {
        propertySupport = true;
        break;
      }
    }
    switch(value) {
      case '2D':
        featureSupport = propertySupport;
        break;
      case '3D':
        if (propertySupport) {
          var body = document.body || document.createElement('body');
          var documentElement = document.documentElement;
          var documentOverflow = documentElement.style.overflow;
          if (!document.body) {
            documentElement.style.overflow = 'hidden';
            documentElement.appendChild(body);
            body.style.overflow = 'hidden';
            body.style.background = '';
          }
          body.appendChild(element);
          element.style[jsProperty] = 'translate3d(1px,1px,1px)';
          propertyValue = window.getComputedStyle(element).getPropertyValue(cssProperty);
          featureSupport = propertyValue !== undefined && propertyValue.length > 0 && propertyValue !== 'none';
          documentElement.style.overflow = documentOverflow;
          body.removeChild(element);
        }
        break;
    }
    return featureSupport;
  };

  Parallax.prototype.ww = null;
  Parallax.prototype.wh = null;
  Parallax.prototype.wcx = null;
  Parallax.prototype.wcy = null;
  Parallax.prototype.wrx = null;
  Parallax.prototype.wry = null;
  Parallax.prototype.portrait = null;
  Parallax.prototype.desktop = !navigator.userAgent.match(/(iPhone|iPod|iPad|Android|BlackBerry|BB10|mobi|tablet|opera mini|nexus 7)/i);
  Parallax.prototype.vendors = [null,['-webkit-','webkit'],['-moz-','Moz'],['-o-','O'],['-ms-','ms']];
  Parallax.prototype.motionSupport = !!window.DeviceMotionEvent;
  Parallax.prototype.orientationSupport = !!window.DeviceOrientationEvent;
  Parallax.prototype.orientationStatus = 0;
  Parallax.prototype.propertyCache = {};

  Parallax.prototype.initialise = function() {

    if (Parallax.prototype.transform2DSupport === undefined) {
      Parallax.prototype.transform2DSupport = Parallax.prototype.transformSupport('2D');
      Parallax.prototype.transform3DSupport = Parallax.prototype.transformSupport('3D');
    }

    // Configure Context Styles
    if (this.transform3DSupport) this.accelerate(this.element);
    var style = window.getComputedStyle(this.element);
    if (style.getPropertyValue('position') === 'static') {
      this.element.style.position = 'relative';
    }

    // Setup
    this.updateLayers();
    this.updateDimensions();
    this.enable();
    this.queueCalibration(this.calibrationDelay);
  };

  Parallax.prototype.updateLayers = function() {

    // Cache Layer Elements
    this.layers = this.element.getElementsByClassName('layer');
    this.depths = [];

    // Configure Layer Styles
    for (var i = 0, l = this.layers.length; i < l; i++) {
      var layer = this.layers[i];
      if (this.transform3DSupport) this.accelerate(layer);

      // Cache Layer Depth
      this.depths.push(this.data(layer, 'depth') || 0);
    }
  };

  Parallax.prototype.updateDimensions = function() {
    this.ww = window.innerWidth;
    this.wh = window.innerHeight;
    this.wcx = this.ww * this.originX;
    this.wcy = this.wh * this.originY;
    this.wrx = Math.max(this.wcx, this.ww - this.wcx);
    this.wry = Math.max(this.wcy, this.wh - this.wcy);
  };

  Parallax.prototype.updateBounds = function() {
    this.bounds = this.element.getBoundingClientRect();
    this.ex = this.bounds.left;
    this.ey = this.bounds.top;
    this.ew = this.bounds.width;
    this.eh = this.bounds.height;
    this.ecx = this.ew * this.originX;
    this.ecy = this.eh * this.originY;
    this.erx = Math.max(this.ecx, this.ew - this.ecx);
    this.ery = Math.max(this.ecy, this.eh - this.ecy);
  };

  Parallax.prototype.queueCalibration = function(delay) {
    clearTimeout(this.calibrationTimer);
    this.calibrationTimer = setTimeout(this.onCalibrationTimer, delay);
  };

  Parallax.prototype.enable = function() {
    if (!this.enabled) {
      this.enabled = true;
      if (this.orientationSupport) {
        this.portrait = null;
        window.addEventListener('deviceorientation', this.onDeviceOrientation);
        setTimeout(this.onOrientationTimer, this.supportDelay);
      } else {
        this.cx = 0;
        this.cy = 0;
        this.portrait = false;
        window.addEventListener('mousemove', this.onMouseMove);
      }
      window.addEventListener('resize', this.onWindowResize);
      this.raf = requestAnimationFrame(this.onAnimationFrame);
    }
  };

  Parallax.prototype.disable = function() {
    if (this.enabled) {
      this.enabled = false;
      if (this.orientationSupport) {
        window.removeEventListener('deviceorientation', this.onDeviceOrientation);
      } else {
        window.removeEventListener('mousemove', this.onMouseMove);
      }
      window.removeEventListener('resize', this.onWindowResize);
      cancelAnimationFrame(this.raf);
    }
  };

  Parallax.prototype.calibrate = function(x, y) {
    this.calibrateX = x === undefined ? this.calibrateX : x;
    this.calibrateY = y === undefined ? this.calibrateY : y;
  };

  Parallax.prototype.invert = function(x, y) {
    this.invertX = x === undefined ? this.invertX : x;
    this.invertY = y === undefined ? this.invertY : y;
  };

  Parallax.prototype.friction = function(x, y) {
    this.frictionX = x === undefined ? this.frictionX : x;
    this.frictionY = y === undefined ? this.frictionY : y;
  };

  Parallax.prototype.scalar = function(x, y) {
    this.scalarX = x === undefined ? this.scalarX : x;
    this.scalarY = y === undefined ? this.scalarY : y;
  };

  Parallax.prototype.limit = function(x, y) {
    this.limitX = x === undefined ? this.limitX : x;
    this.limitY = y === undefined ? this.limitY : y;
  };

  Parallax.prototype.origin = function(x, y) {
    this.originX = x === undefined ? this.originX : x;
    this.originY = y === undefined ? this.originY : y;
  };

  Parallax.prototype.clamp = function(value, min, max) {
    value = Math.max(value, min);
    value = Math.min(value, max);
    return value;
  };

  Parallax.prototype.css = function(element, property, value) {
    var jsProperty = this.propertyCache[property];
    if (!jsProperty) {
      for (var i = 0, l = this.vendors.length; i < l; i++) {
        if (this.vendors[i] !== null) {
          jsProperty = this.camelCase(this.vendors[i][1] + '-' + property);
        } else {
          jsProperty = property;
        }
        if (element.style[jsProperty] !== undefined) {
          this.propertyCache[property] = jsProperty;
          break;
        }
      }
    }
    element.style[jsProperty] = value;
  };

  Parallax.prototype.accelerate = function(element) {
    this.css(element, 'transform', 'translate3d(0,0,0)');
    this.css(element, 'transform-style', 'preserve-3d');
    this.css(element, 'backface-visibility', 'hidden');
  };

  Parallax.prototype.setPosition = function(element, x, y) {
    x += 'px';
    y += 'px';
    if (this.transform3DSupport) {
      this.css(element, 'transform', 'translate3d('+x+','+y+',0)');
    } else if (this.transform2DSupport) {
      this.css(element, 'transform', 'translate('+x+','+y+')');
    } else {
      element.style.left = x;
      element.style.top = y;
    }
  };

  Parallax.prototype.onOrientationTimer = function() {
    if (this.orientationSupport && this.orientationStatus === 0) {
      this.disable();
      this.orientationSupport = false;
      this.enable();
    }
  };

  Parallax.prototype.onCalibrationTimer = function() {
    this.calibrationFlag = true;
  };

  Parallax.prototype.onWindowResize = function() {
    this.updateDimensions();
  };

  Parallax.prototype.onAnimationFrame = function() {
    this.updateBounds();
    var dx = this.ix - this.cx;
    var dy = this.iy - this.cy;
    if ((Math.abs(dx) > this.calibrationThreshold) || (Math.abs(dy) > this.calibrationThreshold)) {
      this.queueCalibration(0);
    }
    if (this.portrait) {
      this.mx = this.calibrateX ? dy : this.iy;
      this.my = this.calibrateY ? dx : this.ix;
    } else {
      this.mx = this.calibrateX ? dx : this.ix;
      this.my = this.calibrateY ? dy : this.iy;
    }
    this.mx *= this.ew * (this.scalarX / 100);
    this.my *= this.eh * (this.scalarY / 100);
    if (!isNaN(parseFloat(this.limitX))) {
      this.mx = this.clamp(this.mx, -this.limitX, this.limitX);
    }
    if (!isNaN(parseFloat(this.limitY))) {
      this.my = this.clamp(this.my, -this.limitY, this.limitY);
    }
    this.vx += (this.mx - this.vx) * this.frictionX;
    this.vy += (this.my - this.vy) * this.frictionY;
    for (var i = 0, l = this.layers.length; i < l; i++) {
      var layer = this.layers[i];
      var depth = this.depths[i];
      var xOffset = this.vx * depth * (this.invertX ? -1 : 1);
      var yOffset = this.vy * depth * (this.invertY ? -1 : 1);
      this.setPosition(layer, xOffset, yOffset);
    }
    this.raf = requestAnimationFrame(this.onAnimationFrame);
  };

  Parallax.prototype.onDeviceOrientation = function(event) {

    // Validate environment and event properties.
    if (!this.desktop && event.beta !== null && event.gamma !== null) {

      // Set orientation status.
      this.orientationStatus = 1;

      // Extract Rotation
      var x = (event.beta  || 0) / MAGIC_NUMBER; //  -90 :: 90
      var y = (event.gamma || 0) / MAGIC_NUMBER; // -180 :: 180

      // Detect Orientation Change
      var portrait = this.wh > this.ww;
      if (this.portrait !== portrait) {
        this.portrait = portrait;
        this.calibrationFlag = true;
      }

      // Set Calibration
      if (this.calibrationFlag) {
        this.calibrationFlag = false;
        this.cx = x;
        this.cy = y;
      }

      // Set Input
      this.ix = x;
      this.iy = y;
    }
  };

  Parallax.prototype.onMouseMove = function(event) {

    // Cache mouse coordinates.
    var clientX = event.clientX;
    var clientY = event.clientY;

    // Calculate Mouse Input
    if (!this.orientationSupport && this.relativeInput) {

      // Clip mouse coordinates inside element bounds.
      if (this.clipRelativeInput) {
        clientX = Math.max(clientX, this.ex);
        clientX = Math.min(clientX, this.ex + this.ew);
        clientY = Math.max(clientY, this.ey);
        clientY = Math.min(clientY, this.ey + this.eh);
      }

      // Calculate input relative to the element.
      this.ix = (clientX - this.ex - this.ecx) / this.erx;
      this.iy = (clientY - this.ey - this.ecy) / this.ery;

    } else {

      // Calculate input relative to the window.
      this.ix = (clientX - this.wcx) / this.wrx;
      this.iy = (clientY - this.wcy) / this.wry;
    }
  };

  // Expose Parallax
  window[NAME] = Parallax;

})(window, document);

/**
 * Request Animation Frame Polyfill.
 * @author Tino Zijdel
 * @author Paul Irish
 * @see https://gist.github.com/paulirish/1579671
 */
;(function() {

  var lastTime = 0;
  var vendors = ['ms', 'moz', 'webkit', 'o'];

  for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
    window.requestAnimationFrame = window[vendors[x]+'RequestAnimationFrame'];
    window.cancelAnimationFrame = window[vendors[x]+'CancelAnimationFrame'] || window[vendors[x]+'CancelRequestAnimationFrame'];
  }

  if (!window.requestAnimationFrame) {
    window.requestAnimationFrame = function(callback, element) {
      var currTime = new Date().getTime();
      var timeToCall = Math.max(0, 16 - (currTime - lastTime));
      var id = window.setTimeout(function() { callback(currTime + timeToCall); },
        timeToCall);
      lastTime = currTime + timeToCall;
      return id;
    };
  }

  if (!window.cancelAnimationFrame) {
    window.cancelAnimationFrame = function(id) {
      clearTimeout(id);
    };
  }

}());
</script>
<script>
var scene5 = document.getElementById('scene5');
var parallax5 = new Parallax(scene5, {
  relativeInput: false,
  clipRelativeInput: false,
  calibrateX: false,
  calibrateY: true,
  invertX: false,
  invertY: true,
  limitX: false,
  limitY: false,
  scalarX: 5,
  scalarY: 5,
  frictionX: 0.8,
  frictionY: 0.8,
  originX: 0.5,
  originY: 0.5
});
</script>

   </body>
</html>
